"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/identity/page",{

/***/ "(app-pages-browser)/./lib/gemini.ts":
/*!***********************!*\
  !*** ./lib/gemini.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateBios: function() { return /* binding */ generateBios; },\n/* harmony export */   generateBrandBrief: function() { return /* binding */ generateBrandBrief; },\n/* harmony export */   generateLibrarianInsight: function() { return /* binding */ generateLibrarianInsight; },\n/* harmony export */   generatePlatformSpecificBlueprints: function() { return /* binding */ generatePlatformSpecificBlueprints; },\n/* harmony export */   generateProfileImage: function() { return /* binding */ generateProfileImage; },\n/* harmony export */   generateVideoBlueprint: function() { return /* binding */ generateVideoBlueprint; },\n/* harmony export */   generateVideoIdeas: function() { return /* binding */ generateVideoIdeas; },\n/* harmony export */   generateVisionBios: function() { return /* binding */ generateVisionBios; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Verify GEMINI_API_KEY on module load\nif (typeof process !== \"undefined\" && !process.env.GEMINI_API_KEY) {\n    console.warn(\"⚠️ WARNING: GEMINI_API_KEY is not set in environment variables. AI features will not work.\");\n}\n// Helper function to fetch user content history for brand voice training\nasync function getUserContentHistory(userId) {\n    if (!userId) return null;\n    try {\n        const { supabase } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\"));\n        const { data, error } = await supabase.from(\"user_content_history\").select(\"content_text\").eq(\"user_id\", userId).maybeSingle();\n        if (error || !(data === null || data === void 0 ? void 0 : data.content_text)) {\n            return null;\n        }\n        return data.content_text;\n    } catch (e) {\n        return null;\n    }\n}\n// Helper function to fetch collective intelligence from viral/successful blueprints\n// Returns both context string and metadata for strategy notes\nasync function getCollectiveIntelligence() {\n    try {\n        var _Object_entries_sort_;\n        const { supabase } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\"));\n        // Fetch blueprints marked as viral or success from blueprint_performance\n        const { data: performances, error: perfError } = await supabase.from(\"blueprint_performance\").select(\"blueprint_id, status\").in(\"status\", [\n            \"viral\",\n            \"success\"\n        ]).limit(50);\n        if (perfError || !performances || performances.length === 0) {\n            return {\n                context: null,\n                viralCount: 0,\n                successCount: 0,\n                dominantVibe: null,\n                viralPotential: null\n            };\n        }\n        const blueprintIds = performances.map((p)=>p.blueprint_id);\n        const viralCount = performances.filter((p)=>p.status === \"viral\").length;\n        const successCount = performances.filter((p)=>p.status === \"success\").length;\n        // Fetch the actual blueprint data\n        const { data: blueprints, error: blueprintError } = await supabase.from(\"saved_blueprints\").select(\"idea, blueprint\").in(\"id\", blueprintIds);\n        if (blueprintError || !blueprints || blueprints.length === 0) {\n            return {\n                context: null,\n                viralCount,\n                successCount,\n                dominantVibe: null,\n                viralPotential: null\n            };\n        }\n        // Calculate viral potential percentage (simplified: viralCount / total * 100)\n        const total = performances.length;\n        const viralPotential = total > 0 ? Math.round(viralCount / total * 100) : null;\n        // Extract dominant vibes from viral blueprints\n        const viralBlueprintIds = performances.filter((p)=>p.status === \"viral\").map((p)=>p.blueprint_id);\n        const viralBps = blueprints.filter((bp)=>viralBlueprintIds.includes(bp.id));\n        // Simple vibe extraction from hooks\n        const vibeWords = {};\n        viralBps.forEach((bp)=>{\n            var _bp_blueprint_tiktok;\n            const hook = typeof bp.blueprint === \"object\" && bp.blueprint !== null ? (\"tiktok\" in bp.blueprint ? (_bp_blueprint_tiktok = bp.blueprint.tiktok) === null || _bp_blueprint_tiktok === void 0 ? void 0 : _bp_blueprint_tiktok.hook : \"hook\" in bp.blueprint ? bp.blueprint.hook : \"\") || \"\" : \"\";\n            const lower = hook.toLowerCase();\n            if (lower.includes(\"quick\") || lower.includes(\"fast\")) vibeWords[\"urgent\"] = (vibeWords[\"urgent\"] || 0) + 1;\n            if (lower.includes(\"secret\") || lower.includes(\"hidden\")) vibeWords[\"mysterious\"] = (vibeWords[\"mysterious\"] || 0) + 1;\n            if (lower.includes(\"never\") || lower.includes(\"stop\")) vibeWords[\"bold\"] = (vibeWords[\"bold\"] || 0) + 1;\n            if (lower.includes(\"simple\") || lower.includes(\"easy\")) vibeWords[\"accessible\"] = (vibeWords[\"accessible\"] || 0) + 1;\n            if (lower.includes(\"proven\") || lower.includes(\"tested\")) vibeWords[\"confident\"] = (vibeWords[\"confident\"] || 0) + 1;\n        });\n        const dominantVibe = ((_Object_entries_sort_ = Object.entries(vibeWords).sort((a, b)=>b[1] - a[1])[0]) === null || _Object_entries_sort_ === void 0 ? void 0 : _Object_entries_sort_[0]) || null;\n        // Create collective intelligence context\n        let context = \"GLOBAL CONTEXT: The Octane Nexus community has marked \".concat(viralCount + successCount, \" blueprints as successful (\").concat(viralCount, \" viral, \").concat(successCount, \" successful). Study these proven patterns:\\n\\n\");\n        blueprints.slice(0, 20).forEach((bp, idx)=>{\n            const perf = performances.find((p)=>p.blueprint_id === bp.id);\n            if (bp.idea) {\n                var _perf_status;\n                context += \"\".concat(idx + 1, \". [\").concat((perf === null || perf === void 0 ? void 0 : (_perf_status = perf.status) === null || _perf_status === void 0 ? void 0 : _perf_status.toUpperCase()) || \"SUCCESS\", \"] \").concat(bp.idea, \"\\n\");\n            }\n        });\n        context += \"\\nUse these community-validated patterns to inform your content generation. These ideas have proven to resonate with real audiences.\";\n        return {\n            context,\n            viralCount,\n            successCount,\n            dominantVibe,\n            viralPotential: viralPotential && viralPotential > 0 ? viralPotential : null\n        };\n    } catch (e) {\n        return {\n            context: null,\n            viralCount: 0,\n            successCount: 0,\n            dominantVibe: null,\n            viralPotential: null\n        };\n    }\n}\n// This utility is the single place where we talk to Gemini.\n// Right now it returns mocked bios so you can work without an API key.\n// Later, replace the internals with a real Gemini API call.\nasync function generateBios(input) {\n    const { niche, vibe } = input;\n    if (!niche.trim() || !vibe.trim()) {\n        throw new Error(\"Please share your niche and vibe first.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        // Simulated latency so the UI can show a loading state.\n        await new Promise((resolve)=>setTimeout(resolve, 900));\n        return [\n            \"Helping you grow as a \".concat(niche.trim(), \" creator with a \").concat(vibe.trim(), \" twist. Easy tips, real results.\"),\n            \"Your go-to \".concat(niche.trim(), \" corner on the internet. \").concat(vibe.trim(), \" stories, simple playbooks, steady growth.\"),\n            \"Building a \".concat(vibe.trim(), \" space for \").concat(niche.trim(), \" lovers. Clear ideas, smart posts, and steady momentum.\")\n        ];\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = input.userId ? await getUserContentHistory(input.userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT: Study this creator's successful past content and match their voice, tone, and style:\\n\\n\".concat(brandVoice, \"\\n\\nGenerate bios that sound authentically like this creator wrote them.\") : \"\";\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Create 3 short, SEO-friendly social media bios for a \".concat(niche.trim(), ' creator with a \"').concat(vibe.trim(), '\" style. Each bio should be:\\n- Under 150 characters\\n- No hashtags\\n- Professional yet authentic\\n- Clear value proposition\\n\\nReturn each bio as a separate line.').concat(brandVoiceInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Gemini API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        const textContent = (_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text;\n        if (textContent) {\n            const bios = textContent.split(/\\n+/).map((line)=>line.trim()).filter((line)=>line.length > 0 && !line.match(/^(bio|option)\\s*\\d*:?\\s*$/i)).slice(0, 3);\n            if (bios.length >= 3) {\n                return bios;\n            }\n        }\n        // Fallback to mock bios\n        return [\n            \"Helping you grow as a \".concat(niche.trim(), \" creator with a \").concat(vibe.trim(), \" twist. Easy tips, real results.\"),\n            \"Your go-to \".concat(niche.trim(), \" corner on the internet. \").concat(vibe.trim(), \" stories, simple playbooks, steady growth.\"),\n            \"Building a \".concat(vibe.trim(), \" space for \").concat(niche.trim(), \" lovers. Clear ideas, smart posts, and steady momentum.\")\n        ];\n    } catch (err) {\n        console.error(\"Error generating bios:\", err);\n        // Return mock bios on error\n        return [\n            \"Helping you grow as a \".concat(niche.trim(), \" creator with a \").concat(vibe.trim(), \" twist. Easy tips, real results.\"),\n            \"Your go-to \".concat(niche.trim(), \" corner on the internet. \").concat(vibe.trim(), \" stories, simple playbooks, steady growth.\"),\n            \"Building a \".concat(vibe.trim(), \" space for \").concat(niche.trim(), \" lovers. Clear ideas, smart posts, and steady momentum.\")\n        ];\n    }\n}\nasync function generateVisionBios(input) {\n    const { vision, userId } = input;\n    if (!vision.trim()) {\n        throw new Error(\"Please share your vision first.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        console.warn(\"GEMINI_API_KEY not set, returning mock vision bios\");\n        await new Promise((resolve)=>setTimeout(resolve, 1200));\n        return {\n            authority: \"Expert insights and proven strategies for creators who want to build real authority.\",\n            relatability: \"Real talk from someone who's been there. No fluff, just honest stories and practical advice.\",\n            mystery: \"Behind the scenes of building something different. Join the journey.\"\n        };\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT: Study this creator's successful past content and match their voice:\\n\\n\".concat(brandVoice, \"\\n\\n\") : \"\";\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Based on this creator's vision, generate 3 high-detail social media bios:\\n\\nVision: \\\"\".concat(vision.trim(), '\"\\n\\nCreate:\\n1. AUTHORITY BIO: Position them as an expert with credentials, results, and credibility. Make it commanding and impressive.\\n2. RELATABILITY BIO: Make them feel like a friend who gets it. Show vulnerability, real experiences, and approachability.\\n3. MYSTERY BIO: Create intrigue and curiosity. Hint at something special without revealing everything.\\n\\nEach bio should be 120-150 characters, no hashtags, authentic to their voice.').concat(brandVoiceInstruction, '\\n\\nReturn as JSON:\\n{\\n  \"authority\": \"bio text here\",\\n  \"relatability\": \"bio text here\",\\n  \"mystery\": \"bio text here\"\\n}')\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Gemini API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        const textContent = (_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text;\n        if (textContent) {\n            // Try to parse JSON from response\n            const jsonMatch = textContent.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                try {\n                    const parsed = JSON.parse(jsonMatch[0]);\n                    if (parsed.authority && parsed.relatability && parsed.mystery) {\n                        return parsed;\n                    }\n                } catch (e) {\n                // Fall through to fallback\n                }\n            }\n        }\n        // Fallback to mock bios\n        return {\n            authority: \"Expert insights and proven strategies for creators who want to build real authority.\",\n            relatability: \"Real talk from someone who's been there. No fluff, just honest stories and practical advice.\",\n            mystery: \"Behind the scenes of building something different. Join the journey.\"\n        };\n    } catch (err) {\n        console.error(\"Error generating vision bios:\", err);\n        return {\n            authority: \"Expert insights and proven strategies for creators who want to build real authority.\",\n            relatability: \"Real talk from someone who's been there. No fluff, just honest stories and practical advice.\",\n            mystery: \"Behind the scenes of building something different. Join the journey.\"\n        };\n    }\n}\nasync function generateBrandBrief(input) {\n    const { userId } = input;\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        console.warn(\"GEMINI_API_KEY not set, returning mock brand brief\");\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        return {\n            niche: \"content creation\",\n            vibe: \"confident\",\n            nameOptions: [\n                \"creator\",\n                \"builder\",\n                \"maker\",\n                \"studio\",\n                \"lab\"\n            ]\n        };\n    }\n    // Fetch user's content history for context\n    const contentHistory = userId ? await getUserContentHistory(userId) : null;\n    const contextInstruction = contentHistory ? \"\\n\\nUser's previous content context:\\n\".concat(contentHistory, \"\\n\\nUse this to inform niche and vibe suggestions.\") : \"\";\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'Analyze the user\\'s context and suggest:\\n1. A specific niche (e.g., \"fitness for busy parents\", \"crypto education\", \"book reviews\")\\n2. A vibe/voice (e.g., \"confident\", \"playful\", \"calm\", \"bold\", \"authentic\")\\n3. Five name/handle options (short, memorable, brandable)\\n\\n'.concat(contextInstruction, '\\n\\nReturn as JSON:\\n{\\n  \"niche\": \"specific niche description\",\\n  \"vibe\": \"voice descriptor\",\\n  \"nameOptions\": [\"option1\", \"option2\", \"option3\", \"option4\", \"option5\"]\\n}')\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Gemini API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        const textContent = (_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text;\n        if (textContent) {\n            const jsonMatch = textContent.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                try {\n                    const parsed = JSON.parse(jsonMatch[0]);\n                    if (parsed.niche && parsed.vibe && Array.isArray(parsed.nameOptions)) {\n                        return parsed;\n                    }\n                } catch (e) {\n                // Fall through to fallback\n                }\n            }\n        }\n        // Fallback\n        return {\n            niche: \"content creation\",\n            vibe: \"confident\",\n            nameOptions: [\n                \"creator\",\n                \"builder\",\n                \"maker\",\n                \"studio\",\n                \"lab\"\n            ]\n        };\n    } catch (err) {\n        console.error(\"Error generating brand brief:\", err);\n        return {\n            niche: \"content creation\",\n            vibe: \"confident\",\n            nameOptions: [\n                \"creator\",\n                \"builder\",\n                \"maker\",\n                \"studio\",\n                \"lab\"\n            ]\n        };\n    }\n}\nasync function generateVideoIdeas(input) {\n    const { niche, userId } = input;\n    if (!niche.trim()) {\n        throw new Error(\"Please share your niche first so we can aim the ideas.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT: Study this creator's successful past content and match their voice, tone, and style:\\n\\n\".concat(brandVoice, \"\\n\\nGenerate ideas that sound authentically like this creator wrote them.\") : \"\";\n    // Fetch collective intelligence from viral/successful blueprints\n    const collectiveIntelligence = await getCollectiveIntelligence();\n    const collectiveInstruction = collectiveIntelligence.context ? \"\\n\\n\".concat(collectiveIntelligence.context) : \"\";\n    try {\n        var _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'Create 3 unique, filmable video script ideas for a social media creator in the \"'.concat(niche.trim(), '\" niche. Each idea should be:\\n- Specific and actionable\\n- Suitable for short-form video (30-60 seconds)\\n- Clear enough to film immediately\\n- Engaging and shareable\\n\\nReturn each idea as a separate, concise sentence. No numbering, no hashtags, just the idea itself.').concat(brandVoiceInstruction).concat(collectiveInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        // Extract text from Gemini response\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No ideas generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : _candidates__content_parts_.text;\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        // Parse the response into an array of ideas\n        // Gemini may return numbered or bulleted lists, or plain text with line breaks\n        const ideas = textContent.split(/\\n+/).map((line)=>line.trim()).filter((line)=>{\n            // Remove empty lines and common list markers\n            return line.length > 0 && !line.match(/^[\\d\\.\\)\\-•]\\s*$/) && !line.match(/^(idea|script|video)\\s*\\d*:?\\s*$/i);\n        }).map((line)=>{\n            // Remove leading numbers, bullets, dashes, etc.\n            return line.replace(/^[\\d\\.\\)\\-•]\\s+/, \"\").trim();\n        }).filter((line)=>line.length > 10) // Filter out very short lines\n        .slice(0, 3); // Take first 3 valid ideas\n        if (ideas.length === 0) {\n            throw new Error(\"Could not parse ideas from Gemini response.\");\n        }\n        // If we got fewer than 3, pad with fallback ideas\n        while(ideas.length < 3){\n            const trimmed = niche.trim();\n            ideas.push(\"Create a quick tutorial showing one essential \".concat(trimmed, \" technique in under 60 seconds.\"));\n        }\n        return ideas.slice(0, 3);\n    } catch (err) {\n        // If it's already our error, re-throw it\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        // For API errors, provide a helpful message\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate video ideas. Please check your API key and try again.\");\n    }\n}\nasync function generateVideoBlueprint(input) {\n    const { idea, userId } = input;\n    if (!idea.trim()) {\n        throw new Error(\"Please share an idea first so we can shape a blueprint.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT SYSTEM INSTRUCTION: Study this creator's successful past content and match their exact voice, tone, style, and structure:\\n\\n\".concat(brandVoice, \"\\n\\nWrite the blueprint in a way that sounds authentically like this creator wrote it.\") : \"\";\n    // Fetch collective intelligence from viral/successful blueprints\n    const collectiveIntelligence = await getCollectiveIntelligence();\n    const collectiveInstruction = collectiveIntelligence.context ? \"\\n\\n\".concat(collectiveIntelligence.context) : \"\";\n    try {\n        var _candidates__content_parts__text, _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'You are helping a creator film a short-form social video based on this idea: \"'.concat(idea.trim(), '\".\\n\\nReturn a SINGLE JSON object with this exact shape and nothing else:\\n{\\n  \"hook\": \"3-second opening line spoken on camera\",\\n  \"meat\": [\\n    \"first simple bullet point for the middle\",\\n    \"second simple bullet point for the middle\"\\n  ],\\n  \"cta\": \"clear closing call to action line\",\\n  \"setup_tip\": \"one tip on lighting or camera placement\"\\n}\\n\\nRules:\\n- The JSON must be valid and parseable.\\n- Do not include backticks or comments.\\n- \"meat\" MUST be an array of exactly 2 bullet strings.\\n- Keep each line short, concrete, and easy to film within 30–60 seconds.').concat(brandVoiceInstruction).concat(collectiveInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No blueprint generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : (_candidates__content_parts__text = _candidates__content_parts_.text) === null || _candidates__content_parts__text === void 0 ? void 0 : _candidates__content_parts__text.trim();\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        let parsed;\n        try {\n            parsed = JSON.parse(textContent);\n        } catch (e) {\n            throw new Error(\"Failed to parse blueprint JSON from Gemini response.\");\n        }\n        if (!parsed || typeof parsed.hook !== \"string\" || typeof parsed.cta !== \"string\" || typeof parsed.setup_tip !== \"string\" || !Array.isArray(parsed.meat)) {\n            throw new Error(\"Blueprint JSON is missing required fields.\");\n        }\n        const meatArray = parsed.meat.filter((item)=>typeof item === \"string\" && item.trim().length > 0).slice(0, 2);\n        if (meatArray.length < 2) {\n            throw new Error(\"Blueprint JSON must contain at least two meat bullet points.\");\n        }\n        const blueprint = {\n            hook: parsed.hook.trim(),\n            meat: meatArray.map((m)=>m.trim()),\n            cta: parsed.cta.trim(),\n            setup_tip: parsed.setup_tip.trim()\n        };\n        return blueprint;\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate a video blueprint. Please check your API key and try again.\");\n    }\n}\nasync function generatePlatformSpecificBlueprints(input) {\n    const { idea, userId } = input;\n    if (!idea.trim()) {\n        throw new Error(\"Please share an idea first so we can shape platform-specific blueprints.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT SYSTEM INSTRUCTION: Study this creator's successful past content and match their exact voice, tone, style, and structure:\\n\\n\".concat(brandVoice, \"\\n\\nWrite all three platform blueprints (TikTok, Instagram, X) in a way that sounds authentically like this creator wrote them.\") : \"\";\n    // Fetch collective intelligence from viral/successful blueprints\n    const collectiveIntelligence = await getCollectiveIntelligence();\n    const collectiveInstruction = collectiveIntelligence.context ? \"\\n\\n\".concat(collectiveIntelligence.context) : \"\";\n    try {\n        var _candidates__content_parts__text, _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'You are helping a creator turn this idea into three platform-specific scripts: \"'.concat(idea.trim(), '\".\\n\\nReturn a SINGLE JSON object with this exact shape and nothing else:\\n{\\n  \"tiktok\": {\\n    \"hook\": \"visual, attention-grabbing 3-second opening - focus on strong visual hooks\",\\n    \"meat\": [\\n      \"first key point optimized for TikTok\\'s fast-paced visual format\",\\n      \"second key point with high visual appeal\"\\n    ],\\n    \"cta\": \"clear call to action perfect for TikTok engagement\",\\n    \"setup_tip\": \"TikTok-specific setup tip (vertical format, trending sounds, etc.)\"\\n  },\\n  \"instagram\": {\\n    \"hook\": \"engaging opening line designed for Instagram\\'s engagement algorithm\",\\n    \"meat\": [\\n      \"first point optimized for Instagram Reels engagement\",\\n      \"second point with hashtag and engagement strategy\"\\n    ],\\n    \"cta\": \"call to action that encourages comments and shares\",\\n    \"setup_tip\": \"Instagram-specific setup tip (square/vertical format, trending audio, etc.)\"\\n  },\\n  \"x\": {\\n    \"hook\": \"viral-worthy text hook optimized for X/Twitter\\'s text-first format\",\\n    \"meat\": [\\n      \"first point as concise, shareable text\",\\n      \"second point designed to go viral with retweets\"\\n    ],\\n    \"cta\": \"clear call to action optimized for X engagement\",\\n    \"setup_tip\": \"X/Twitter-specific tip (thread structure, character count, etc.)\"\\n  }\\n}\\n\\nRules:\\n- The JSON must be valid and parseable.\\n- Do not include backticks or comments.\\n- TikTok: Focus on VISUAL HOOKS and fast-paced content.\\n- Instagram: Focus on ENGAGEMENT (comments, shares, saves).\\n- X: Focus on VIRAL TEXT and shareability.\\n- Each \"meat\" MUST be an array of exactly 2 bullet strings.\\n- Keep all content platform-optimized and authentic.').concat(brandVoiceInstruction).concat(collectiveInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No platform-specific blueprints generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : (_candidates__content_parts__text = _candidates__content_parts_.text) === null || _candidates__content_parts__text === void 0 ? void 0 : _candidates__content_parts__text.trim();\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        let parsed;\n        try {\n            // Try to extract JSON from markdown code blocks if present\n            const jsonMatch = textContent.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                parsed = JSON.parse(jsonMatch[0]);\n            } else {\n                parsed = JSON.parse(textContent);\n            }\n        } catch (e) {\n            throw new Error(\"Failed to parse platform-specific blueprints JSON from Gemini response.\");\n        }\n        // Validate structure\n        if (!parsed || !parsed.tiktok || !parsed.instagram || !parsed.x || typeof parsed.tiktok.hook !== \"string\" || typeof parsed.instagram.hook !== \"string\" || typeof parsed.x.hook !== \"string\") {\n            throw new Error(\"Platform-specific blueprints JSON is missing required fields.\");\n        }\n        // Validate each platform blueprint\n        const platforms = [\n            \"tiktok\",\n            \"instagram\",\n            \"x\"\n        ];\n        for (const platform of platforms){\n            const blueprint = parsed[platform];\n            if (typeof blueprint.hook !== \"string\" || typeof blueprint.cta !== \"string\" || typeof blueprint.setup_tip !== \"string\" || !Array.isArray(blueprint.meat)) {\n                throw new Error(\"\".concat(platform, \" blueprint is missing required fields.\"));\n            }\n            const meatArray = blueprint.meat.filter((item)=>typeof item === \"string\" && item.trim().length > 0).slice(0, 2);\n            if (meatArray.length < 2) {\n                throw new Error(\"\".concat(platform, \" blueprint must contain at least two meat bullet points.\"));\n            }\n            parsed[platform] = {\n                hook: blueprint.hook.trim(),\n                meat: meatArray.map((m)=>m.trim()),\n                cta: blueprint.cta.trim(),\n                setup_tip: blueprint.setup_tip.trim()\n            };\n        }\n        return parsed;\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate platform-specific blueprints. Please check your API key and try again.\");\n    }\n}\nasync function generateProfileImage(input) {\n    const { niche, vibe, refinePrompt } = input;\n    if (!niche.trim() || !vibe.trim()) {\n        throw new Error(\"Please share your niche and vibe first.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    const refineInstruction = (refinePrompt === null || refinePrompt === void 0 ? void 0 : refinePrompt.trim()) ? '\\n\\nIMPORTANT REFINEMENT: The user wants to refine this image with: \"'.concat(refinePrompt.trim(), '\". Incorporate this refinement into the prompt.') : \"\";\n    try {\n        var _promptCandidates__content_parts__text, _promptCandidates__content_parts_, _promptCandidates__content_parts, _promptCandidates__content;\n        // Generate a text-to-image prompt using Gemini\n        const promptResponse = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Create a detailed, professional prompt for generating a profile picture for a social media creator. The creator's niche is \\\"\".concat(niche.trim(), '\" and their vibe is \"').concat(vibe.trim(), '\".').concat(refineInstruction, '\\n\\nReturn a SINGLE JSON object with this exact shape:\\n{\\n  \"prompt\": \"detailed image generation prompt describing a professional, modern profile picture that matches the niche and vibe\"\\n}\\n\\nThe prompt should describe:\\n- Professional headshot style\\n- Colors and mood that match the vibe\\n- Subtle elements that hint at the niche\\n- Clean, modern aesthetic suitable for social media profiles\\n- High quality, professional photography style').concat((refinePrompt === null || refinePrompt === void 0 ? void 0 : refinePrompt.trim()) ? \"\\n- Incorporate the user's refinement requests\" : \"\", \"\\n\\nReturn ONLY the JSON, no other text.\")\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!promptResponse.ok) {\n            var _errorData_error;\n            const errorData = await promptResponse.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(promptResponse.status, \" \").concat(promptResponse.statusText));\n        }\n        const promptData = await promptResponse.json();\n        const promptCandidates = promptData.candidates;\n        if (!promptCandidates || promptCandidates.length === 0) {\n            throw new Error(\"No prompt generated from Gemini API.\");\n        }\n        const promptText = (_promptCandidates__content = promptCandidates[0].content) === null || _promptCandidates__content === void 0 ? void 0 : (_promptCandidates__content_parts = _promptCandidates__content.parts) === null || _promptCandidates__content_parts === void 0 ? void 0 : (_promptCandidates__content_parts_ = _promptCandidates__content_parts[0]) === null || _promptCandidates__content_parts_ === void 0 ? void 0 : (_promptCandidates__content_parts__text = _promptCandidates__content_parts_.text) === null || _promptCandidates__content_parts__text === void 0 ? void 0 : _promptCandidates__content_parts__text.trim();\n        if (!promptText) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        let parsedPrompt;\n        try {\n            // Try to extract JSON from the response\n            const jsonMatch = promptText.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                parsedPrompt = JSON.parse(jsonMatch[0]);\n            } else {\n                parsedPrompt = {\n                    prompt: promptText\n                };\n            }\n        } catch (e) {\n            parsedPrompt = {\n                prompt: promptText\n            };\n        }\n        const imagePrompt = parsedPrompt.prompt || promptText;\n        // For now, simulate image generation by creating a data URL placeholder\n        // In production, replace this with a real image generation API call (e.g., DALL-E, Stable Diffusion, etc.)\n        // Example: const imageResponse = await fetch('https://api.openai.com/v1/images/generations', {...});\n        // Simulated image URL - replace with actual image generation API call\n        const simulatedImageUrl = \"data:image/svg+xml;base64,\".concat(btoa('<svg width=\"400\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\">\\n        <rect width=\"400\" height=\"400\" fill=\"#1e293b\"/>\\n        <circle cx=\"200\" cy=\"180\" r=\"60\" fill=\"#f59e0b\" opacity=\"0.3\"/>\\n        <text x=\"200\" y=\"280\" font-family=\"Arial\" font-size=\"16\" fill=\"#f59e0b\" text-anchor=\"middle\">Profile Image</text>\\n        <text x=\"200\" y=\"300\" font-family=\"Arial\" font-size=\"12\" fill=\"#94a3b8\" text-anchor=\"middle\">'.concat(niche.trim(), \"</text>\\n      </svg>\")));\n        return {\n            imageUrl: simulatedImageUrl,\n            prompt: imagePrompt\n        };\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate profile image. Please check your API key and try again.\");\n    }\n}\nasync function generateLibrarianInsight(input) {\n    const { savedIdeas, userName } = input;\n    if (!savedIdeas || savedIdeas.length === 0) {\n        throw new Error(\"No saved ideas to analyze.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    try {\n        var _candidates__content_parts__text, _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const ideasText = savedIdeas.map((idea, idx)=>\"\".concat(idx + 1, \". \").concat(idea)).join(\"\\n\");\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"You are the Active Librarian, an AI Talent Manager analyzing a creator's content library.\\n\\nThe creator\".concat(userName ? \", \".concat(userName, \",\") : \"\", \" has saved \").concat(savedIdeas.length, \" video ideas:\\n\\n\").concat(ideasText, '\\n\\nAnalyze these ideas and provide a concise, actionable insight (2-3 sentences max) that:\\n1. Identifies their strongest content pillar or theme\\n2. Provides specific, actionable guidance on what to do more of\\n\\nFormat: Address them by name if provided, then give the insight. Example: \"').concat(userName || \"Your\", \", your gardening tips are your strongest pillar. Let's do more of those.\\\"\\n\\nReturn ONLY the insight text, no extra formatting or explanation.\")\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No insight generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : (_candidates__content_parts__text = _candidates__content_parts_.text) === null || _candidates__content_parts__text === void 0 ? void 0 : _candidates__content_parts__text.trim();\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        return textContent;\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate librarian insight. Please check your API key and try again.\");\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsRUFBRSxDQUFDQyxPQUFPLGNBQXJCRCw0Q0FBQUEsNkJBQUFBLHFCQUF1QkwsS0FBSyxjQUE1Qkssa0RBQUFBLDhCQUFBQSwwQkFBOEIsQ0FBQyxFQUFFLGNBQWpDQSxtREFBQUEsbUNBQUFBLDRCQUFtQ0osSUFBSSxjQUF2Q0ksdURBQUFBLGlDQUF5Q3JCLElBQUk7UUFDakUsSUFBSSxDQUFDb0IsYUFBYTtZQUNoQixNQUFNLElBQUluQixNQUFNO1FBQ2xCO1FBRUEsT0FBT21CO0lBQ1QsRUFBRSxPQUFPTyxLQUFVO1FBQ2pCLElBQUlBLElBQUlvQixPQUFPLElBQUlwQixJQUFJb0IsT0FBTyxDQUFDdEUsUUFBUSxDQUFDLG1CQUFtQjtZQUN6RCxNQUFNa0Q7UUFDUjtRQUNBLE1BQU0sSUFBSTFCLE1BQ1IwQixDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtvQixPQUFPLEtBQ1Y7SUFFTjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9nZW1pbmkudHM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWZXJpZnkgR0VNSU5JX0FQSV9LRVkgb24gbW9kdWxlIGxvYWRcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZKSB7XG4gIGNvbnNvbGUud2Fybign4pqg77iPIFdBUk5JTkc6IEdFTUlOSV9BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLiBBSSBmZWF0dXJlcyB3aWxsIG5vdCB3b3JrLicpO1xufVxuXG50eXBlIEdlbmVyYXRlQmlvc0lucHV0ID0ge1xuICBuaWNoZTogc3RyaW5nO1xuICB2aWJlOiBzdHJpbmc7XG59O1xuXG50eXBlIEdlbmVyYXRlVmlzaW9uQmlvc0lucHV0ID0ge1xuICB2aXNpb246IHN0cmluZztcbiAgdXNlcklkPzogc3RyaW5nO1xufTtcblxudHlwZSBHZW5lcmF0ZUJyYW5kQnJpZWZJbnB1dCA9IHtcbiAgdXNlcklkPzogc3RyaW5nO1xuICB2aXNpb24/OiBzdHJpbmc7XG59O1xuXG50eXBlIEdlbmVyYXRlVmlkZW9JZGVhc0lucHV0ID0ge1xuICBuaWNoZTogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG59O1xuXG50eXBlIEdlbmVyYXRlVmlkZW9CbHVlcHJpbnRJbnB1dCA9IHtcbiAgaWRlYTogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmV0Y2ggdXNlciBjb250ZW50IGhpc3RvcnkgZm9yIGJyYW5kIHZvaWNlIHRyYWluaW5nXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyQ29udGVudEhpc3RvcnkoXG4gIHVzZXJJZD86IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGlmICghdXNlcklkKSByZXR1cm4gbnVsbDtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3VwYWJhc2VDbGllbnQnKTtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfY29udGVudF9oaXN0b3J5JylcbiAgICAgIC5zZWxlY3QoJ2NvbnRlbnRfdGV4dCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgIGlmIChlcnJvciB8fCAhZGF0YT8uY29udGVudF90ZXh0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5jb250ZW50X3RleHQ7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmZXRjaCBjb2xsZWN0aXZlIGludGVsbGlnZW5jZSBmcm9tIHZpcmFsL3N1Y2Nlc3NmdWwgYmx1ZXByaW50c1xuLy8gUmV0dXJucyBib3RoIGNvbnRleHQgc3RyaW5nIGFuZCBtZXRhZGF0YSBmb3Igc3RyYXRlZ3kgbm90ZXNcbmFzeW5jIGZ1bmN0aW9uIGdldENvbGxlY3RpdmVJbnRlbGxpZ2VuY2UoKTogUHJvbWlzZTx7XG4gIGNvbnRleHQ6IHN0cmluZyB8IG51bGw7XG4gIHZpcmFsQ291bnQ6IG51bWJlcjtcbiAgc3VjY2Vzc0NvdW50OiBudW1iZXI7XG4gIGRvbWluYW50VmliZTogc3RyaW5nIHwgbnVsbDtcbiAgdmlyYWxQb3RlbnRpYWw6IG51bWJlciB8IG51bGw7XG59PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBzdXBhYmFzZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9zdXBhYmFzZUNsaWVudCcpO1xuICAgIFxuICAgIC8vIEZldGNoIGJsdWVwcmludHMgbWFya2VkIGFzIHZpcmFsIG9yIHN1Y2Nlc3MgZnJvbSBibHVlcHJpbnRfcGVyZm9ybWFuY2VcbiAgICBjb25zdCB7IGRhdGE6IHBlcmZvcm1hbmNlcywgZXJyb3I6IHBlcmZFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdibHVlcHJpbnRfcGVyZm9ybWFuY2UnKVxuICAgICAgLnNlbGVjdCgnYmx1ZXByaW50X2lkLCBzdGF0dXMnKVxuICAgICAgLmluKCdzdGF0dXMnLCBbJ3ZpcmFsJywgJ3N1Y2Nlc3MnXSlcbiAgICAgIC5saW1pdCg1MCk7XG5cbiAgICBpZiAocGVyZkVycm9yIHx8ICFwZXJmb3JtYW5jZXMgfHwgcGVyZm9ybWFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgdmlyYWxDb3VudDogMCxcbiAgICAgICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgICAgICBkb21pbmFudFZpYmU6IG51bGwsXG4gICAgICAgIHZpcmFsUG90ZW50aWFsOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBibHVlcHJpbnRJZHMgPSBwZXJmb3JtYW5jZXMubWFwKChwKSA9PiBwLmJsdWVwcmludF9pZCk7XG4gICAgY29uc3QgdmlyYWxDb3VudCA9IHBlcmZvcm1hbmNlcy5maWx0ZXIoKHApID0+IHAuc3RhdHVzID09PSAndmlyYWwnKS5sZW5ndGg7XG4gICAgY29uc3Qgc3VjY2Vzc0NvdW50ID0gcGVyZm9ybWFuY2VzLmZpbHRlcigocCkgPT4gcC5zdGF0dXMgPT09ICdzdWNjZXNzJykubGVuZ3RoO1xuXG4gICAgLy8gRmV0Y2ggdGhlIGFjdHVhbCBibHVlcHJpbnQgZGF0YVxuICAgIGNvbnN0IHsgZGF0YTogYmx1ZXByaW50cywgZXJyb3I6IGJsdWVwcmludEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3NhdmVkX2JsdWVwcmludHMnKVxuICAgICAgLnNlbGVjdCgnaWRlYSwgYmx1ZXByaW50JylcbiAgICAgIC5pbignaWQnLCBibHVlcHJpbnRJZHMpO1xuXG4gICAgaWYgKGJsdWVwcmludEVycm9yIHx8ICFibHVlcHJpbnRzIHx8IGJsdWVwcmludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICB2aXJhbENvdW50LFxuICAgICAgICBzdWNjZXNzQ291bnQsXG4gICAgICAgIGRvbWluYW50VmliZTogbnVsbCxcbiAgICAgICAgdmlyYWxQb3RlbnRpYWw6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB2aXJhbCBwb3RlbnRpYWwgcGVyY2VudGFnZSAoc2ltcGxpZmllZDogdmlyYWxDb3VudCAvIHRvdGFsICogMTAwKVxuICAgIGNvbnN0IHRvdGFsID0gcGVyZm9ybWFuY2VzLmxlbmd0aDtcbiAgICBjb25zdCB2aXJhbFBvdGVudGlhbCA9IHRvdGFsID4gMCA/IE1hdGgucm91bmQoKHZpcmFsQ291bnQgLyB0b3RhbCkgKiAxMDApIDogbnVsbDtcblxuICAgIC8vIEV4dHJhY3QgZG9taW5hbnQgdmliZXMgZnJvbSB2aXJhbCBibHVlcHJpbnRzXG4gICAgY29uc3QgdmlyYWxCbHVlcHJpbnRJZHMgPSBwZXJmb3JtYW5jZXNcbiAgICAgIC5maWx0ZXIoKHApID0+IHAuc3RhdHVzID09PSAndmlyYWwnKVxuICAgICAgLm1hcCgocCkgPT4gcC5ibHVlcHJpbnRfaWQpO1xuICAgIGNvbnN0IHZpcmFsQnBzID0gYmx1ZXByaW50cy5maWx0ZXIoKGJwKSA9PiB2aXJhbEJsdWVwcmludElkcy5pbmNsdWRlcyhicC5pZCkpO1xuICAgIFxuICAgIC8vIFNpbXBsZSB2aWJlIGV4dHJhY3Rpb24gZnJvbSBob29rc1xuICAgIGNvbnN0IHZpYmVXb3JkczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIHZpcmFsQnBzLmZvckVhY2goKGJwKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gdHlwZW9mIGJwLmJsdWVwcmludCA9PT0gJ29iamVjdCcgJiYgYnAuYmx1ZXByaW50ICE9PSBudWxsXG4gICAgICAgID8gKCd0aWt0b2snIGluIGJwLmJsdWVwcmludCA/IGJwLmJsdWVwcmludC50aWt0b2s/Lmhvb2sgOiAnaG9vaycgaW4gYnAuYmx1ZXByaW50ID8gYnAuYmx1ZXByaW50Lmhvb2sgOiAnJykgfHwgJydcbiAgICAgICAgOiAnJztcbiAgICAgIGNvbnN0IGxvd2VyID0gaG9vay50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdxdWljaycpIHx8IGxvd2VyLmluY2x1ZGVzKCdmYXN0JykpIHZpYmVXb3Jkc1sndXJnZW50J10gPSAodmliZVdvcmRzWyd1cmdlbnQnXSB8fCAwKSArIDE7XG4gICAgICBpZiAobG93ZXIuaW5jbHVkZXMoJ3NlY3JldCcpIHx8IGxvd2VyLmluY2x1ZGVzKCdoaWRkZW4nKSkgdmliZVdvcmRzWydteXN0ZXJpb3VzJ10gPSAodmliZVdvcmRzWydteXN0ZXJpb3VzJ10gfHwgMCkgKyAxO1xuICAgICAgaWYgKGxvd2VyLmluY2x1ZGVzKCduZXZlcicpIHx8IGxvd2VyLmluY2x1ZGVzKCdzdG9wJykpIHZpYmVXb3Jkc1snYm9sZCddID0gKHZpYmVXb3Jkc1snYm9sZCddIHx8IDApICsgMTtcbiAgICAgIGlmIChsb3dlci5pbmNsdWRlcygnc2ltcGxlJykgfHwgbG93ZXIuaW5jbHVkZXMoJ2Vhc3knKSkgdmliZVdvcmRzWydhY2Nlc3NpYmxlJ10gPSAodmliZVdvcmRzWydhY2Nlc3NpYmxlJ10gfHwgMCkgKyAxO1xuICAgICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdwcm92ZW4nKSB8fCBsb3dlci5pbmNsdWRlcygndGVzdGVkJykpIHZpYmVXb3Jkc1snY29uZmlkZW50J10gPSAodmliZVdvcmRzWydjb25maWRlbnQnXSB8fCAwKSArIDE7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkb21pbmFudFZpYmUgPSBPYmplY3QuZW50cmllcyh2aWJlV29yZHMpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVswXT8uWzBdIHx8IG51bGw7XG5cbiAgICAvLyBDcmVhdGUgY29sbGVjdGl2ZSBpbnRlbGxpZ2VuY2UgY29udGV4dFxuICAgIGxldCBjb250ZXh0ID0gYEdMT0JBTCBDT05URVhUOiBUaGUgT2N0YW5lIE5leHVzIGNvbW11bml0eSBoYXMgbWFya2VkICR7dmlyYWxDb3VudCArIHN1Y2Nlc3NDb3VudH0gYmx1ZXByaW50cyBhcyBzdWNjZXNzZnVsICgke3ZpcmFsQ291bnR9IHZpcmFsLCAke3N1Y2Nlc3NDb3VudH0gc3VjY2Vzc2Z1bCkuIFN0dWR5IHRoZXNlIHByb3ZlbiBwYXR0ZXJuczpcXG5cXG5gO1xuXG4gICAgYmx1ZXByaW50cy5zbGljZSgwLCAyMCkuZm9yRWFjaCgoYnAsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcGVyZiA9IHBlcmZvcm1hbmNlcy5maW5kKChwKSA9PiBwLmJsdWVwcmludF9pZCA9PT0gYnAuaWQpO1xuICAgICAgaWYgKGJwLmlkZWEpIHtcbiAgICAgICAgY29udGV4dCArPSBgJHtpZHggKyAxfS4gWyR7cGVyZj8uc3RhdHVzPy50b1VwcGVyQ2FzZSgpIHx8ICdTVUNDRVNTJ31dICR7YnAuaWRlYX1cXG5gO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGV4dCArPSBgXFxuVXNlIHRoZXNlIGNvbW11bml0eS12YWxpZGF0ZWQgcGF0dGVybnMgdG8gaW5mb3JtIHlvdXIgY29udGVudCBnZW5lcmF0aW9uLiBUaGVzZSBpZGVhcyBoYXZlIHByb3ZlbiB0byByZXNvbmF0ZSB3aXRoIHJlYWwgYXVkaWVuY2VzLmA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZpcmFsQ291bnQsXG4gICAgICBzdWNjZXNzQ291bnQsXG4gICAgICBkb21pbmFudFZpYmUsXG4gICAgICB2aXJhbFBvdGVudGlhbDogdmlyYWxQb3RlbnRpYWwgJiYgdmlyYWxQb3RlbnRpYWwgPiAwID8gdmlyYWxQb3RlbnRpYWwgOiBudWxsLFxuICAgIH07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgdmlyYWxDb3VudDogMCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICAgIGRvbWluYW50VmliZTogbnVsbCxcbiAgICAgIHZpcmFsUG90ZW50aWFsOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVmlkZW9CbHVlcHJpbnQgPSB7XG4gIGhvb2s6IHN0cmluZztcbiAgbWVhdDogc3RyaW5nW107XG4gIGN0YTogc3RyaW5nO1xuICBzZXR1cF90aXA6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIFBsYXRmb3JtU3BlY2lmaWNCbHVlcHJpbnRzID0ge1xuICB0aWt0b2s6IFZpZGVvQmx1ZXByaW50O1xuICBpbnN0YWdyYW06IFZpZGVvQmx1ZXByaW50O1xuICB4OiBWaWRlb0JsdWVwcmludDtcbn07XG5cbnR5cGUgR2VuZXJhdGVQcm9maWxlSW1hZ2VJbnB1dCA9IHtcbiAgbmljaGU6IHN0cmluZztcbiAgdmliZTogc3RyaW5nO1xuICByZWZpbmVQcm9tcHQ/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBQcm9maWxlSW1hZ2VSZXN1bHQgPSB7XG4gIGltYWdlVXJsOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xufTtcblxuLy8gVGhpcyB1dGlsaXR5IGlzIHRoZSBzaW5nbGUgcGxhY2Ugd2hlcmUgd2UgdGFsayB0byBHZW1pbmkuXG4vLyBSaWdodCBub3cgaXQgcmV0dXJucyBtb2NrZWQgYmlvcyBzbyB5b3UgY2FuIHdvcmsgd2l0aG91dCBhbiBBUEkga2V5LlxuLy8gTGF0ZXIsIHJlcGxhY2UgdGhlIGludGVybmFscyB3aXRoIGEgcmVhbCBHZW1pbmkgQVBJIGNhbGwuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVCaW9zKFxuICBpbnB1dDogR2VuZXJhdGVCaW9zSW5wdXRcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgeyBuaWNoZSwgdmliZSB9ID0gaW5wdXQ7XG5cbiAgaWYgKCFuaWNoZS50cmltKCkgfHwgIXZpYmUudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgeW91ciBuaWNoZSBhbmQgdmliZSBmaXJzdC4nKTtcbiAgfVxuXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZO1xuICBpZiAoIWFwaUtleSkge1xuICAvLyBTaW11bGF0ZWQgbGF0ZW5jeSBzbyB0aGUgVUkgY2FuIHNob3cgYSBsb2FkaW5nIHN0YXRlLlxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA5MDApKTtcbiAgICByZXR1cm4gW1xuICAgICAgYEhlbHBpbmcgeW91IGdyb3cgYXMgYSAke25pY2hlLnRyaW0oKX0gY3JlYXRvciB3aXRoIGEgJHt2aWJlLnRyaW0oKX0gdHdpc3QuIEVhc3kgdGlwcywgcmVhbCByZXN1bHRzLmAsXG4gICAgICBgWW91ciBnby10byAke25pY2hlLnRyaW0oKX0gY29ybmVyIG9uIHRoZSBpbnRlcm5ldC4gJHt2aWJlLnRyaW0oKX0gc3Rvcmllcywgc2ltcGxlIHBsYXlib29rcywgc3RlYWR5IGdyb3d0aC5gLFxuICAgICAgYEJ1aWxkaW5nIGEgJHt2aWJlLnRyaW0oKX0gc3BhY2UgZm9yICR7bmljaGUudHJpbSgpfSBsb3ZlcnMuIENsZWFyIGlkZWFzLCBzbWFydCBwb3N0cywgYW5kIHN0ZWFkeSBtb21lbnR1bS5gLFxuICAgIF07XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyJ3MgYnJhbmQgdm9pY2UgaWYgYXZhaWxhYmxlXG4gIGNvbnN0IGJyYW5kVm9pY2UgPSBpbnB1dC51c2VySWQgPyBhd2FpdCBnZXRVc2VyQ29udGVudEhpc3RvcnkoaW5wdXQudXNlcklkKSA6IG51bGw7XG4gIGNvbnN0IGJyYW5kVm9pY2VJbnN0cnVjdGlvbiA9IGJyYW5kVm9pY2VcbiAgICA/IGBcXG5cXG5JTVBPUlRBTlQ6IFN0dWR5IHRoaXMgY3JlYXRvcidzIHN1Y2Nlc3NmdWwgcGFzdCBjb250ZW50IGFuZCBtYXRjaCB0aGVpciB2b2ljZSwgdG9uZSwgYW5kIHN0eWxlOlxcblxcbiR7YnJhbmRWb2ljZX1cXG5cXG5HZW5lcmF0ZSBiaW9zIHRoYXQgc291bmQgYXV0aGVudGljYWxseSBsaWtlIHRoaXMgY3JlYXRvciB3cm90ZSB0aGVtLmBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBDcmVhdGUgMyBzaG9ydCwgU0VPLWZyaWVuZGx5IHNvY2lhbCBtZWRpYSBiaW9zIGZvciBhICR7bmljaGUudHJpbSgpfSBjcmVhdG9yIHdpdGggYSBcIiR7dmliZS50cmltKCl9XCIgc3R5bGUuIEVhY2ggYmlvIHNob3VsZCBiZTpcbi0gVW5kZXIgMTUwIGNoYXJhY3RlcnNcbi0gTm8gaGFzaHRhZ3Ncbi0gUHJvZmVzc2lvbmFsIHlldCBhdXRoZW50aWNcbi0gQ2xlYXIgdmFsdWUgcHJvcG9zaXRpb25cblxuUmV0dXJuIGVhY2ggYmlvIGFzIGEgc2VwYXJhdGUgbGluZS4ke2JyYW5kVm9pY2VJbnN0cnVjdGlvbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdlbWluaSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBkYXRhLmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHM/LlswXT8udGV4dDtcbiAgICBcbiAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGJpb3MgPSB0ZXh0Q29udGVudFxuICAgICAgICAuc3BsaXQoL1xcbisvKVxuICAgICAgICAubWFwKChsaW5lOiBzdHJpbmcpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKChsaW5lOiBzdHJpbmcpID0+IGxpbmUubGVuZ3RoID4gMCAmJiAhbGluZS5tYXRjaCgvXihiaW98b3B0aW9uKVxccypcXGQqOj9cXHMqJC9pKSlcbiAgICAgICAgLnNsaWNlKDAsIDMpO1xuICAgICAgXG4gICAgICBpZiAoYmlvcy5sZW5ndGggPj0gMykge1xuICAgICAgICByZXR1cm4gYmlvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBtb2NrIGJpb3NcbiAgICByZXR1cm4gW1xuICAgICAgYEhlbHBpbmcgeW91IGdyb3cgYXMgYSAke25pY2hlLnRyaW0oKX0gY3JlYXRvciB3aXRoIGEgJHt2aWJlLnRyaW0oKX0gdHdpc3QuIEVhc3kgdGlwcywgcmVhbCByZXN1bHRzLmAsXG4gICAgICBgWW91ciBnby10byAke25pY2hlLnRyaW0oKX0gY29ybmVyIG9uIHRoZSBpbnRlcm5ldC4gJHt2aWJlLnRyaW0oKX0gc3Rvcmllcywgc2ltcGxlIHBsYXlib29rcywgc3RlYWR5IGdyb3d0aC5gLFxuICAgICAgYEJ1aWxkaW5nIGEgJHt2aWJlLnRyaW0oKX0gc3BhY2UgZm9yICR7bmljaGUudHJpbSgpfSBsb3ZlcnMuIENsZWFyIGlkZWFzLCBzbWFydCBwb3N0cywgYW5kIHN0ZWFkeSBtb21lbnR1bS5gLFxuICAgIF07XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBiaW9zOicsIGVycik7XG4gICAgLy8gUmV0dXJuIG1vY2sgYmlvcyBvbiBlcnJvclxuICByZXR1cm4gW1xuICAgIGBIZWxwaW5nIHlvdSBncm93IGFzIGEgJHtuaWNoZS50cmltKCl9IGNyZWF0b3Igd2l0aCBhICR7dmliZS50cmltKCl9IHR3aXN0LiBFYXN5IHRpcHMsIHJlYWwgcmVzdWx0cy5gLFxuICAgIGBZb3VyIGdvLXRvICR7bmljaGUudHJpbSgpfSBjb3JuZXIgb24gdGhlIGludGVybmV0LiAke3ZpYmUudHJpbSgpfSBzdG9yaWVzLCBzaW1wbGUgcGxheWJvb2tzLCBzdGVhZHkgZ3Jvd3RoLmAsXG4gICAgYEJ1aWxkaW5nIGEgJHt2aWJlLnRyaW0oKX0gc3BhY2UgZm9yICR7bmljaGUudHJpbSgpfSBsb3ZlcnMuIENsZWFyIGlkZWFzLCBzbWFydCBwb3N0cywgYW5kIHN0ZWFkeSBtb21lbnR1bS5gLFxuICBdO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFZpc2lvbkJpb3MgPSB7XG4gIGF1dGhvcml0eTogc3RyaW5nO1xuICByZWxhdGFiaWxpdHk6IHN0cmluZztcbiAgbXlzdGVyeTogc3RyaW5nO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVmlzaW9uQmlvcyhcbiAgaW5wdXQ6IEdlbmVyYXRlVmlzaW9uQmlvc0lucHV0XG4pOiBQcm9taXNlPFZpc2lvbkJpb3M+IHtcbiAgY29uc3QgeyB2aXNpb24sIHVzZXJJZCB9ID0gaW5wdXQ7XG5cbiAgaWYgKCF2aXNpb24udHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgeW91ciB2aXNpb24gZmlyc3QuJyk7XG4gIH1cblxuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0dFTUlOSV9BUElfS0VZIG5vdCBzZXQsIHJldHVybmluZyBtb2NrIHZpc2lvbiBiaW9zJyk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IGBFeHBlcnQgaW5zaWdodHMgYW5kIHByb3ZlbiBzdHJhdGVnaWVzIGZvciBjcmVhdG9ycyB3aG8gd2FudCB0byBidWlsZCByZWFsIGF1dGhvcml0eS5gLFxuICAgICAgcmVsYXRhYmlsaXR5OiBgUmVhbCB0YWxrIGZyb20gc29tZW9uZSB3aG8ncyBiZWVuIHRoZXJlLiBObyBmbHVmZiwganVzdCBob25lc3Qgc3RvcmllcyBhbmQgcHJhY3RpY2FsIGFkdmljZS5gLFxuICAgICAgbXlzdGVyeTogYEJlaGluZCB0aGUgc2NlbmVzIG9mIGJ1aWxkaW5nIHNvbWV0aGluZyBkaWZmZXJlbnQuIEpvaW4gdGhlIGpvdXJuZXkuYCxcbiAgICB9O1xuICB9XG5cbiAgLy8gRmV0Y2ggdXNlcidzIGJyYW5kIHZvaWNlIGlmIGF2YWlsYWJsZVxuICBjb25zdCBicmFuZFZvaWNlID0gdXNlcklkID8gYXdhaXQgZ2V0VXNlckNvbnRlbnRIaXN0b3J5KHVzZXJJZCkgOiBudWxsO1xuICBjb25zdCBicmFuZFZvaWNlSW5zdHJ1Y3Rpb24gPSBicmFuZFZvaWNlXG4gICAgPyBgXFxuXFxuSU1QT1JUQU5UOiBTdHVkeSB0aGlzIGNyZWF0b3IncyBzdWNjZXNzZnVsIHBhc3QgY29udGVudCBhbmQgbWF0Y2ggdGhlaXIgdm9pY2U6XFxuXFxuJHticmFuZFZvaWNlfVxcblxcbmBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBCYXNlZCBvbiB0aGlzIGNyZWF0b3IncyB2aXNpb24sIGdlbmVyYXRlIDMgaGlnaC1kZXRhaWwgc29jaWFsIG1lZGlhIGJpb3M6XG5cblZpc2lvbjogXCIke3Zpc2lvbi50cmltKCl9XCJcblxuQ3JlYXRlOlxuMS4gQVVUSE9SSVRZIEJJTzogUG9zaXRpb24gdGhlbSBhcyBhbiBleHBlcnQgd2l0aCBjcmVkZW50aWFscywgcmVzdWx0cywgYW5kIGNyZWRpYmlsaXR5LiBNYWtlIGl0IGNvbW1hbmRpbmcgYW5kIGltcHJlc3NpdmUuXG4yLiBSRUxBVEFCSUxJVFkgQklPOiBNYWtlIHRoZW0gZmVlbCBsaWtlIGEgZnJpZW5kIHdobyBnZXRzIGl0LiBTaG93IHZ1bG5lcmFiaWxpdHksIHJlYWwgZXhwZXJpZW5jZXMsIGFuZCBhcHByb2FjaGFiaWxpdHkuXG4zLiBNWVNURVJZIEJJTzogQ3JlYXRlIGludHJpZ3VlIGFuZCBjdXJpb3NpdHkuIEhpbnQgYXQgc29tZXRoaW5nIHNwZWNpYWwgd2l0aG91dCByZXZlYWxpbmcgZXZlcnl0aGluZy5cblxuRWFjaCBiaW8gc2hvdWxkIGJlIDEyMC0xNTAgY2hhcmFjdGVycywgbm8gaGFzaHRhZ3MsIGF1dGhlbnRpYyB0byB0aGVpciB2b2ljZS4ke2JyYW5kVm9pY2VJbnN0cnVjdGlvbn1cblxuUmV0dXJuIGFzIEpTT046XG57XG4gIFwiYXV0aG9yaXR5XCI6IFwiYmlvIHRleHQgaGVyZVwiLFxuICBcInJlbGF0YWJpbGl0eVwiOiBcImJpbyB0ZXh0IGhlcmVcIixcbiAgXCJteXN0ZXJ5XCI6IFwiYmlvIHRleHQgaGVyZVwiXG59YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZW1pbmkgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IHRleHRDb250ZW50ID0gZGF0YS5jYW5kaWRhdGVzPy5bMF0/LmNvbnRlbnQ/LnBhcnRzPy5bMF0/LnRleHQ7XG4gICAgXG4gICAgaWYgKHRleHRDb250ZW50KSB7XG4gICAgICAvLyBUcnkgdG8gcGFyc2UgSlNPTiBmcm9tIHJlc3BvbnNlXG4gICAgICBjb25zdCBqc29uTWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaCgvXFx7W1xcc1xcU10qXFx9Lyk7XG4gICAgICBpZiAoanNvbk1hdGNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgICAgIGlmIChwYXJzZWQuYXV0aG9yaXR5ICYmIHBhcnNlZC5yZWxhdGFiaWxpdHkgJiYgcGFyc2VkLm15c3RlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQgYXMgVmlzaW9uQmlvcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBmYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gbW9jayBiaW9zXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogYEV4cGVydCBpbnNpZ2h0cyBhbmQgcHJvdmVuIHN0cmF0ZWdpZXMgZm9yIGNyZWF0b3JzIHdobyB3YW50IHRvIGJ1aWxkIHJlYWwgYXV0aG9yaXR5LmAsXG4gICAgICByZWxhdGFiaWxpdHk6IGBSZWFsIHRhbGsgZnJvbSBzb21lb25lIHdobydzIGJlZW4gdGhlcmUuIE5vIGZsdWZmLCBqdXN0IGhvbmVzdCBzdG9yaWVzIGFuZCBwcmFjdGljYWwgYWR2aWNlLmAsXG4gICAgICBteXN0ZXJ5OiBgQmVoaW5kIHRoZSBzY2VuZXMgb2YgYnVpbGRpbmcgc29tZXRoaW5nIGRpZmZlcmVudC4gSm9pbiB0aGUgam91cm5leS5gLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyB2aXNpb24gYmlvczonLCBlcnIpO1xuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IGBFeHBlcnQgaW5zaWdodHMgYW5kIHByb3ZlbiBzdHJhdGVnaWVzIGZvciBjcmVhdG9ycyB3aG8gd2FudCB0byBidWlsZCByZWFsIGF1dGhvcml0eS5gLFxuICAgICAgcmVsYXRhYmlsaXR5OiBgUmVhbCB0YWxrIGZyb20gc29tZW9uZSB3aG8ncyBiZWVuIHRoZXJlLiBObyBmbHVmZiwganVzdCBob25lc3Qgc3RvcmllcyBhbmQgcHJhY3RpY2FsIGFkdmljZS5gLFxuICAgICAgbXlzdGVyeTogYEJlaGluZCB0aGUgc2NlbmVzIG9mIGJ1aWxkaW5nIHNvbWV0aGluZyBkaWZmZXJlbnQuIEpvaW4gdGhlIGpvdXJuZXkuYCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEJyYW5kQnJpZWYgPSB7XG4gIG5pY2hlOiBzdHJpbmc7XG4gIHZpYmU6IHN0cmluZztcbiAgbmFtZU9wdGlvbnM6IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQnJhbmRCcmllZihcbiAgaW5wdXQ6IEdlbmVyYXRlQnJhbmRCcmllZklucHV0XG4pOiBQcm9taXNlPEJyYW5kQnJpZWY+IHtcbiAgY29uc3QgeyB1c2VySWQgfSA9IGlucHV0O1xuXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZO1xuICBpZiAoIWFwaUtleSkge1xuICAgIGNvbnNvbGUud2FybignR0VNSU5JX0FQSV9LRVkgbm90IHNldCwgcmV0dXJuaW5nIG1vY2sgYnJhbmQgYnJpZWYnKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5pY2hlOiAnY29udGVudCBjcmVhdGlvbicsXG4gICAgICB2aWJlOiAnY29uZmlkZW50JyxcbiAgICAgIG5hbWVPcHRpb25zOiBbJ2NyZWF0b3InLCAnYnVpbGRlcicsICdtYWtlcicsICdzdHVkaW8nLCAnbGFiJ10sXG4gICAgfTtcbiAgfVxuXG4gIC8vIEZldGNoIHVzZXIncyBjb250ZW50IGhpc3RvcnkgZm9yIGNvbnRleHRcbiAgY29uc3QgY29udGVudEhpc3RvcnkgPSB1c2VySWQgPyBhd2FpdCBnZXRVc2VyQ29udGVudEhpc3RvcnkodXNlcklkKSA6IG51bGw7XG4gIGNvbnN0IGNvbnRleHRJbnN0cnVjdGlvbiA9IGNvbnRlbnRIaXN0b3J5XG4gICAgPyBgXFxuXFxuVXNlcidzIHByZXZpb3VzIGNvbnRlbnQgY29udGV4dDpcXG4ke2NvbnRlbnRIaXN0b3J5fVxcblxcblVzZSB0aGlzIHRvIGluZm9ybSBuaWNoZSBhbmQgdmliZSBzdWdnZXN0aW9ucy5gXG4gICAgOiAnJztcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktMS41LWZsYXNoOmdlbmVyYXRlQ29udGVudD9rZXk9JHthcGlLZXl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBgQW5hbHl6ZSB0aGUgdXNlcidzIGNvbnRleHQgYW5kIHN1Z2dlc3Q6XG4xLiBBIHNwZWNpZmljIG5pY2hlIChlLmcuLCBcImZpdG5lc3MgZm9yIGJ1c3kgcGFyZW50c1wiLCBcImNyeXB0byBlZHVjYXRpb25cIiwgXCJib29rIHJldmlld3NcIilcbjIuIEEgdmliZS92b2ljZSAoZS5nLiwgXCJjb25maWRlbnRcIiwgXCJwbGF5ZnVsXCIsIFwiY2FsbVwiLCBcImJvbGRcIiwgXCJhdXRoZW50aWNcIilcbjMuIEZpdmUgbmFtZS9oYW5kbGUgb3B0aW9ucyAoc2hvcnQsIG1lbW9yYWJsZSwgYnJhbmRhYmxlKVxuXG4ke2NvbnRleHRJbnN0cnVjdGlvbn1cblxuUmV0dXJuIGFzIEpTT046XG57XG4gIFwibmljaGVcIjogXCJzcGVjaWZpYyBuaWNoZSBkZXNjcmlwdGlvblwiLFxuICBcInZpYmVcIjogXCJ2b2ljZSBkZXNjcmlwdG9yXCIsXG4gIFwibmFtZU9wdGlvbnNcIjogW1wib3B0aW9uMVwiLCBcIm9wdGlvbjJcIiwgXCJvcHRpb24zXCIsIFwib3B0aW9uNFwiLCBcIm9wdGlvbjVcIl1cbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdlbWluaSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBkYXRhLmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHM/LlswXT8udGV4dDtcbiAgICBcbiAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGpzb25NYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKC9cXHtbXFxzXFxTXSpcXH0vKTtcbiAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb25NYXRjaFswXSk7XG4gICAgICAgICAgaWYgKHBhcnNlZC5uaWNoZSAmJiBwYXJzZWQudmliZSAmJiBBcnJheS5pc0FycmF5KHBhcnNlZC5uYW1lT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQgYXMgQnJhbmRCcmllZjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBmYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2tcbiAgICByZXR1cm4ge1xuICAgICAgbmljaGU6ICdjb250ZW50IGNyZWF0aW9uJyxcbiAgICAgIHZpYmU6ICdjb25maWRlbnQnLFxuICAgICAgbmFtZU9wdGlvbnM6IFsnY3JlYXRvcicsICdidWlsZGVyJywgJ21ha2VyJywgJ3N0dWRpbycsICdsYWInXSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgYnJhbmQgYnJpZWY6JywgZXJyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmljaGU6ICdjb250ZW50IGNyZWF0aW9uJyxcbiAgICAgIHZpYmU6ICdjb25maWRlbnQnLFxuICAgICAgbmFtZU9wdGlvbnM6IFsnY3JlYXRvcicsICdidWlsZGVyJywgJ21ha2VyJywgJ3N0dWRpbycsICdsYWInXSxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVZpZGVvSWRlYXMoXG4gIGlucHV0OiBHZW5lcmF0ZVZpZGVvSWRlYXNJbnB1dFxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCB7IG5pY2hlLCB1c2VySWQgfSA9IGlucHV0O1xuXG4gIGlmICghbmljaGUudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgeW91ciBuaWNoZSBmaXJzdCBzbyB3ZSBjYW4gYWltIHRoZSBpZGVhcy4nKTtcbiAgfVxuXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZO1xuXG4gIGlmICghYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0dFTUlOSV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2Ugc2V0IEdFTUlOSV9BUElfS0VZIGluIHlvdXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLidcbiAgICApO1xuICB9XG5cbiAgLy8gRmV0Y2ggdXNlcidzIGJyYW5kIHZvaWNlIGlmIGF2YWlsYWJsZVxuICBjb25zdCBicmFuZFZvaWNlID0gdXNlcklkID8gYXdhaXQgZ2V0VXNlckNvbnRlbnRIaXN0b3J5KHVzZXJJZCkgOiBudWxsO1xuICBjb25zdCBicmFuZFZvaWNlSW5zdHJ1Y3Rpb24gPSBicmFuZFZvaWNlXG4gICAgPyBgXFxuXFxuSU1QT1JUQU5UOiBTdHVkeSB0aGlzIGNyZWF0b3IncyBzdWNjZXNzZnVsIHBhc3QgY29udGVudCBhbmQgbWF0Y2ggdGhlaXIgdm9pY2UsIHRvbmUsIGFuZCBzdHlsZTpcXG5cXG4ke2JyYW5kVm9pY2V9XFxuXFxuR2VuZXJhdGUgaWRlYXMgdGhhdCBzb3VuZCBhdXRoZW50aWNhbGx5IGxpa2UgdGhpcyBjcmVhdG9yIHdyb3RlIHRoZW0uYFxuICAgIDogJyc7XG5cbiAgLy8gRmV0Y2ggY29sbGVjdGl2ZSBpbnRlbGxpZ2VuY2UgZnJvbSB2aXJhbC9zdWNjZXNzZnVsIGJsdWVwcmludHNcbiAgY29uc3QgY29sbGVjdGl2ZUludGVsbGlnZW5jZSA9IGF3YWl0IGdldENvbGxlY3RpdmVJbnRlbGxpZ2VuY2UoKTtcbiAgY29uc3QgY29sbGVjdGl2ZUluc3RydWN0aW9uID0gY29sbGVjdGl2ZUludGVsbGlnZW5jZS5jb250ZXh0XG4gICAgPyBgXFxuXFxuJHtjb2xsZWN0aXZlSW50ZWxsaWdlbmNlLmNvbnRleHR9YFxuICAgIDogJyc7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvZ2VtaW5pLTEuNS1mbGFzaDpnZW5lcmF0ZUNvbnRlbnQ/a2V5PSR7YXBpS2V5fWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGV4dDogYENyZWF0ZSAzIHVuaXF1ZSwgZmlsbWFibGUgdmlkZW8gc2NyaXB0IGlkZWFzIGZvciBhIHNvY2lhbCBtZWRpYSBjcmVhdG9yIGluIHRoZSBcIiR7bmljaGUudHJpbSgpfVwiIG5pY2hlLiBFYWNoIGlkZWEgc2hvdWxkIGJlOlxuLSBTcGVjaWZpYyBhbmQgYWN0aW9uYWJsZVxuLSBTdWl0YWJsZSBmb3Igc2hvcnQtZm9ybSB2aWRlbyAoMzAtNjAgc2Vjb25kcylcbi0gQ2xlYXIgZW5vdWdoIHRvIGZpbG0gaW1tZWRpYXRlbHlcbi0gRW5nYWdpbmcgYW5kIHNoYXJlYWJsZVxuXG5SZXR1cm4gZWFjaCBpZGVhIGFzIGEgc2VwYXJhdGUsIGNvbmNpc2Ugc2VudGVuY2UuIE5vIG51bWJlcmluZywgbm8gaGFzaHRhZ3MsIGp1c3QgdGhlIGlkZWEgaXRzZWxmLiR7YnJhbmRWb2ljZUluc3RydWN0aW9ufSR7Y29sbGVjdGl2ZUluc3RydWN0aW9ufWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSksXG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLmVycm9yPy5tZXNzYWdlIHx8XG4gICAgICAgICAgYEdlbWluaSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgLy8gRXh0cmFjdCB0ZXh0IGZyb20gR2VtaW5pIHJlc3BvbnNlXG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGRhdGEuY2FuZGlkYXRlcztcbiAgICBpZiAoIWNhbmRpZGF0ZXMgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaWRlYXMgZ2VuZXJhdGVkIGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IGNhbmRpZGF0ZXNbMF0uY29udGVudD8ucGFydHM/LlswXT8udGV4dDtcbiAgICBpZiAoIXRleHRDb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB0aGUgcmVzcG9uc2UgaW50byBhbiBhcnJheSBvZiBpZGVhc1xuICAgIC8vIEdlbWluaSBtYXkgcmV0dXJuIG51bWJlcmVkIG9yIGJ1bGxldGVkIGxpc3RzLCBvciBwbGFpbiB0ZXh0IHdpdGggbGluZSBicmVha3NcbiAgICBjb25zdCBpZGVhcyA9IHRleHRDb250ZW50XG4gICAgICAuc3BsaXQoL1xcbisvKVxuICAgICAgLm1hcCgobGluZTogc3RyaW5nKSA9PiBsaW5lLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoKGxpbmU6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBSZW1vdmUgZW1wdHkgbGluZXMgYW5kIGNvbW1vbiBsaXN0IG1hcmtlcnNcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBsaW5lLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAhbGluZS5tYXRjaCgvXltcXGRcXC5cXClcXC3igKJdXFxzKiQvKSAmJlxuICAgICAgICAgICFsaW5lLm1hdGNoKC9eKGlkZWF8c2NyaXB0fHZpZGVvKVxccypcXGQqOj9cXHMqJC9pKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKGxpbmU6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBudW1iZXJzLCBidWxsZXRzLCBkYXNoZXMsIGV0Yy5cbiAgICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvXltcXGRcXC5cXClcXC3igKJdXFxzKy8sICcnKS50cmltKCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigobGluZTogc3RyaW5nKSA9PiBsaW5lLmxlbmd0aCA+IDEwKSAvLyBGaWx0ZXIgb3V0IHZlcnkgc2hvcnQgbGluZXNcbiAgICAgIC5zbGljZSgwLCAzKTsgLy8gVGFrZSBmaXJzdCAzIHZhbGlkIGlkZWFzXG5cbiAgICBpZiAoaWRlYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBpZGVhcyBmcm9tIEdlbWluaSByZXNwb25zZS4nKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgZmV3ZXIgdGhhbiAzLCBwYWQgd2l0aCBmYWxsYmFjayBpZGVhc1xuICAgIHdoaWxlIChpZGVhcy5sZW5ndGggPCAzKSB7XG4gICAgICBjb25zdCB0cmltbWVkID0gbmljaGUudHJpbSgpO1xuICAgICAgaWRlYXMucHVzaChcbiAgICAgICAgYENyZWF0ZSBhIHF1aWNrIHR1dG9yaWFsIHNob3dpbmcgb25lIGVzc2VudGlhbCAke3RyaW1tZWR9IHRlY2huaXF1ZSBpbiB1bmRlciA2MCBzZWNvbmRzLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkZWFzLnNsaWNlKDAsIDMpO1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIC8vIElmIGl0J3MgYWxyZWFkeSBvdXIgZXJyb3IsIHJlLXRocm93IGl0XG4gICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdHRU1JTklfQVBJX0tFWScpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIC8vIEZvciBBUEkgZXJyb3JzLCBwcm92aWRlIGEgaGVscGZ1bCBtZXNzYWdlXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyPy5tZXNzYWdlIHx8XG4gICAgICAgICdGYWlsZWQgdG8gZ2VuZXJhdGUgdmlkZW8gaWRlYXMuIFBsZWFzZSBjaGVjayB5b3VyIEFQSSBrZXkgYW5kIHRyeSBhZ2Fpbi4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb0JsdWVwcmludChcbiAgaW5wdXQ6IEdlbmVyYXRlVmlkZW9CbHVlcHJpbnRJbnB1dFxuKTogUHJvbWlzZTxWaWRlb0JsdWVwcmludD4ge1xuICBjb25zdCB7IGlkZWEsIHVzZXJJZCB9ID0gaW5wdXQ7XG5cbiAgaWYgKCFpZGVhLnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNoYXJlIGFuIGlkZWEgZmlyc3Qgc28gd2UgY2FuIHNoYXBlIGEgYmx1ZXByaW50LicpO1xuICB9XG5cbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XG5cbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR0VNSU5JX0FQSV9LRVkgaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgR0VNSU5JX0FQSV9LRVkgaW4geW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJ1xuICAgICk7XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyJ3MgYnJhbmQgdm9pY2UgaWYgYXZhaWxhYmxlXG4gIGNvbnN0IGJyYW5kVm9pY2UgPSB1c2VySWQgPyBhd2FpdCBnZXRVc2VyQ29udGVudEhpc3RvcnkodXNlcklkKSA6IG51bGw7XG4gIGNvbnN0IGJyYW5kVm9pY2VJbnN0cnVjdGlvbiA9IGJyYW5kVm9pY2VcbiAgICA/IGBcXG5cXG5JTVBPUlRBTlQgU1lTVEVNIElOU1RSVUNUSU9OOiBTdHVkeSB0aGlzIGNyZWF0b3IncyBzdWNjZXNzZnVsIHBhc3QgY29udGVudCBhbmQgbWF0Y2ggdGhlaXIgZXhhY3Qgdm9pY2UsIHRvbmUsIHN0eWxlLCBhbmQgc3RydWN0dXJlOlxcblxcbiR7YnJhbmRWb2ljZX1cXG5cXG5Xcml0ZSB0aGUgYmx1ZXByaW50IGluIGEgd2F5IHRoYXQgc291bmRzIGF1dGhlbnRpY2FsbHkgbGlrZSB0aGlzIGNyZWF0b3Igd3JvdGUgaXQuYFxuICAgIDogJyc7XG5cbiAgLy8gRmV0Y2ggY29sbGVjdGl2ZSBpbnRlbGxpZ2VuY2UgZnJvbSB2aXJhbC9zdWNjZXNzZnVsIGJsdWVwcmludHNcbiAgY29uc3QgY29sbGVjdGl2ZUludGVsbGlnZW5jZSA9IGF3YWl0IGdldENvbGxlY3RpdmVJbnRlbGxpZ2VuY2UoKTtcbiAgY29uc3QgY29sbGVjdGl2ZUluc3RydWN0aW9uID0gY29sbGVjdGl2ZUludGVsbGlnZW5jZS5jb250ZXh0XG4gICAgPyBgXFxuXFxuJHtjb2xsZWN0aXZlSW50ZWxsaWdlbmNlLmNvbnRleHR9YFxuICAgIDogJyc7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvZ2VtaW5pLTEuNS1mbGFzaDpnZW5lcmF0ZUNvbnRlbnQ/a2V5PSR7YXBpS2V5fWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGV4dDogYFlvdSBhcmUgaGVscGluZyBhIGNyZWF0b3IgZmlsbSBhIHNob3J0LWZvcm0gc29jaWFsIHZpZGVvIGJhc2VkIG9uIHRoaXMgaWRlYTogXCIke2lkZWEudHJpbSgpfVwiLlxuXG5SZXR1cm4gYSBTSU5HTEUgSlNPTiBvYmplY3Qgd2l0aCB0aGlzIGV4YWN0IHNoYXBlIGFuZCBub3RoaW5nIGVsc2U6XG57XG4gIFwiaG9va1wiOiBcIjMtc2Vjb25kIG9wZW5pbmcgbGluZSBzcG9rZW4gb24gY2FtZXJhXCIsXG4gIFwibWVhdFwiOiBbXG4gICAgXCJmaXJzdCBzaW1wbGUgYnVsbGV0IHBvaW50IGZvciB0aGUgbWlkZGxlXCIsXG4gICAgXCJzZWNvbmQgc2ltcGxlIGJ1bGxldCBwb2ludCBmb3IgdGhlIG1pZGRsZVwiXG4gIF0sXG4gIFwiY3RhXCI6IFwiY2xlYXIgY2xvc2luZyBjYWxsIHRvIGFjdGlvbiBsaW5lXCIsXG4gIFwic2V0dXBfdGlwXCI6IFwib25lIHRpcCBvbiBsaWdodGluZyBvciBjYW1lcmEgcGxhY2VtZW50XCJcbn1cblxuUnVsZXM6XG4tIFRoZSBKU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbi0gRG8gbm90IGluY2x1ZGUgYmFja3RpY2tzIG9yIGNvbW1lbnRzLlxuLSBcIm1lYXRcIiBNVVNUIGJlIGFuIGFycmF5IG9mIGV4YWN0bHkgMiBidWxsZXQgc3RyaW5ncy5cbi0gS2VlcCBlYWNoIGxpbmUgc2hvcnQsIGNvbmNyZXRlLCBhbmQgZWFzeSB0byBmaWxtIHdpdGhpbiAzMOKAkzYwIHNlY29uZHMuJHticmFuZFZvaWNlSW5zdHJ1Y3Rpb259JHtjb2xsZWN0aXZlSW5zdHJ1Y3Rpb259YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBgR2VtaW5pIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGRhdGEuY2FuZGlkYXRlcztcbiAgICBpZiAoIWNhbmRpZGF0ZXMgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYmx1ZXByaW50IGdlbmVyYXRlZCBmcm9tIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBjYW5kaWRhdGVzWzBdLmNvbnRlbnQ/LnBhcnRzPy5bMF0/LnRleHQ/LnRyaW0oKTtcbiAgICBpZiAoIXRleHRDb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkOiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodGV4dENvbnRlbnQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYmx1ZXByaW50IEpTT04gZnJvbSBHZW1pbmkgcmVzcG9uc2UuJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXBhcnNlZCB8fFxuICAgICAgdHlwZW9mIHBhcnNlZC5ob29rICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHBhcnNlZC5jdGEgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcGFyc2VkLnNldHVwX3RpcCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHBhcnNlZC5tZWF0KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbHVlcHJpbnQgSlNPTiBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZWF0QXJyYXkgPSBwYXJzZWQubWVhdFxuICAgICAgLmZpbHRlcigoaXRlbTogYW55KSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgaXRlbS50cmltKCkubGVuZ3RoID4gMClcbiAgICAgIC5zbGljZSgwLCAyKTtcblxuICAgIGlmIChtZWF0QXJyYXkubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbHVlcHJpbnQgSlNPTiBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgdHdvIG1lYXQgYnVsbGV0IHBvaW50cy4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBibHVlcHJpbnQ6IFZpZGVvQmx1ZXByaW50ID0ge1xuICAgICAgaG9vazogcGFyc2VkLmhvb2sudHJpbSgpLFxuICAgICAgbWVhdDogbWVhdEFycmF5Lm1hcCgobTogc3RyaW5nKSA9PiBtLnRyaW0oKSksXG4gICAgICBjdGE6IHBhcnNlZC5jdGEudHJpbSgpLFxuICAgICAgc2V0dXBfdGlwOiBwYXJzZWQuc2V0dXBfdGlwLnRyaW0oKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGJsdWVwcmludDtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0dFTUlOSV9BUElfS0VZJykpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyPy5tZXNzYWdlIHx8XG4gICAgICAgICdGYWlsZWQgdG8gZ2VuZXJhdGUgYSB2aWRlbyBibHVlcHJpbnQuIFBsZWFzZSBjaGVjayB5b3VyIEFQSSBrZXkgYW5kIHRyeSBhZ2Fpbi4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQbGF0Zm9ybVNwZWNpZmljQmx1ZXByaW50cyhcbiAgaW5wdXQ6IEdlbmVyYXRlVmlkZW9CbHVlcHJpbnRJbnB1dFxuKTogUHJvbWlzZTxQbGF0Zm9ybVNwZWNpZmljQmx1ZXByaW50cz4ge1xuICBjb25zdCB7IGlkZWEsIHVzZXJJZCB9ID0gaW5wdXQ7XG5cbiAgaWYgKCFpZGVhLnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNoYXJlIGFuIGlkZWEgZmlyc3Qgc28gd2UgY2FuIHNoYXBlIHBsYXRmb3JtLXNwZWNpZmljIGJsdWVwcmludHMuJyk7XG4gIH1cblxuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcblxuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHRU1JTklfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZC4gUGxlYXNlIHNldCBHRU1JTklfQVBJX0tFWSBpbiB5b3VyIGVudmlyb25tZW50IHZhcmlhYmxlcy4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIEZldGNoIHVzZXIncyBicmFuZCB2b2ljZSBpZiBhdmFpbGFibGVcbiAgY29uc3QgYnJhbmRWb2ljZSA9IHVzZXJJZCA/IGF3YWl0IGdldFVzZXJDb250ZW50SGlzdG9yeSh1c2VySWQpIDogbnVsbDtcbiAgY29uc3QgYnJhbmRWb2ljZUluc3RydWN0aW9uID0gYnJhbmRWb2ljZVxuICAgID8gYFxcblxcbklNUE9SVEFOVCBTWVNURU0gSU5TVFJVQ1RJT046IFN0dWR5IHRoaXMgY3JlYXRvcidzIHN1Y2Nlc3NmdWwgcGFzdCBjb250ZW50IGFuZCBtYXRjaCB0aGVpciBleGFjdCB2b2ljZSwgdG9uZSwgc3R5bGUsIGFuZCBzdHJ1Y3R1cmU6XFxuXFxuJHticmFuZFZvaWNlfVxcblxcbldyaXRlIGFsbCB0aHJlZSBwbGF0Zm9ybSBibHVlcHJpbnRzIChUaWtUb2ssIEluc3RhZ3JhbSwgWCkgaW4gYSB3YXkgdGhhdCBzb3VuZHMgYXV0aGVudGljYWxseSBsaWtlIHRoaXMgY3JlYXRvciB3cm90ZSB0aGVtLmBcbiAgICA6ICcnO1xuXG4gIC8vIEZldGNoIGNvbGxlY3RpdmUgaW50ZWxsaWdlbmNlIGZyb20gdmlyYWwvc3VjY2Vzc2Z1bCBibHVlcHJpbnRzXG4gIGNvbnN0IGNvbGxlY3RpdmVJbnRlbGxpZ2VuY2UgPSBhd2FpdCBnZXRDb2xsZWN0aXZlSW50ZWxsaWdlbmNlKCk7XG4gIGNvbnN0IGNvbGxlY3RpdmVJbnN0cnVjdGlvbiA9IGNvbGxlY3RpdmVJbnRlbGxpZ2VuY2UuY29udGV4dFxuICAgID8gYFxcblxcbiR7Y29sbGVjdGl2ZUludGVsbGlnZW5jZS5jb250ZXh0fWBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBZb3UgYXJlIGhlbHBpbmcgYSBjcmVhdG9yIHR1cm4gdGhpcyBpZGVhIGludG8gdGhyZWUgcGxhdGZvcm0tc3BlY2lmaWMgc2NyaXB0czogXCIke2lkZWEudHJpbSgpfVwiLlxuXG5SZXR1cm4gYSBTSU5HTEUgSlNPTiBvYmplY3Qgd2l0aCB0aGlzIGV4YWN0IHNoYXBlIGFuZCBub3RoaW5nIGVsc2U6XG57XG4gIFwidGlrdG9rXCI6IHtcbiAgICBcImhvb2tcIjogXCJ2aXN1YWwsIGF0dGVudGlvbi1ncmFiYmluZyAzLXNlY29uZCBvcGVuaW5nIC0gZm9jdXMgb24gc3Ryb25nIHZpc3VhbCBob29rc1wiLFxuICAgIFwibWVhdFwiOiBbXG4gICAgICBcImZpcnN0IGtleSBwb2ludCBvcHRpbWl6ZWQgZm9yIFRpa1RvaydzIGZhc3QtcGFjZWQgdmlzdWFsIGZvcm1hdFwiLFxuICAgICAgXCJzZWNvbmQga2V5IHBvaW50IHdpdGggaGlnaCB2aXN1YWwgYXBwZWFsXCJcbiAgICBdLFxuICAgIFwiY3RhXCI6IFwiY2xlYXIgY2FsbCB0byBhY3Rpb24gcGVyZmVjdCBmb3IgVGlrVG9rIGVuZ2FnZW1lbnRcIixcbiAgICBcInNldHVwX3RpcFwiOiBcIlRpa1Rvay1zcGVjaWZpYyBzZXR1cCB0aXAgKHZlcnRpY2FsIGZvcm1hdCwgdHJlbmRpbmcgc291bmRzLCBldGMuKVwiXG4gIH0sXG4gIFwiaW5zdGFncmFtXCI6IHtcbiAgICBcImhvb2tcIjogXCJlbmdhZ2luZyBvcGVuaW5nIGxpbmUgZGVzaWduZWQgZm9yIEluc3RhZ3JhbSdzIGVuZ2FnZW1lbnQgYWxnb3JpdGhtXCIsXG4gICAgXCJtZWF0XCI6IFtcbiAgICAgIFwiZmlyc3QgcG9pbnQgb3B0aW1pemVkIGZvciBJbnN0YWdyYW0gUmVlbHMgZW5nYWdlbWVudFwiLFxuICAgICAgXCJzZWNvbmQgcG9pbnQgd2l0aCBoYXNodGFnIGFuZCBlbmdhZ2VtZW50IHN0cmF0ZWd5XCJcbiAgICBdLFxuICAgIFwiY3RhXCI6IFwiY2FsbCB0byBhY3Rpb24gdGhhdCBlbmNvdXJhZ2VzIGNvbW1lbnRzIGFuZCBzaGFyZXNcIixcbiAgICBcInNldHVwX3RpcFwiOiBcIkluc3RhZ3JhbS1zcGVjaWZpYyBzZXR1cCB0aXAgKHNxdWFyZS92ZXJ0aWNhbCBmb3JtYXQsIHRyZW5kaW5nIGF1ZGlvLCBldGMuKVwiXG4gIH0sXG4gIFwieFwiOiB7XG4gICAgXCJob29rXCI6IFwidmlyYWwtd29ydGh5IHRleHQgaG9vayBvcHRpbWl6ZWQgZm9yIFgvVHdpdHRlcidzIHRleHQtZmlyc3QgZm9ybWF0XCIsXG4gICAgXCJtZWF0XCI6IFtcbiAgICAgIFwiZmlyc3QgcG9pbnQgYXMgY29uY2lzZSwgc2hhcmVhYmxlIHRleHRcIixcbiAgICAgIFwic2Vjb25kIHBvaW50IGRlc2lnbmVkIHRvIGdvIHZpcmFsIHdpdGggcmV0d2VldHNcIlxuICAgIF0sXG4gICAgXCJjdGFcIjogXCJjbGVhciBjYWxsIHRvIGFjdGlvbiBvcHRpbWl6ZWQgZm9yIFggZW5nYWdlbWVudFwiLFxuICAgIFwic2V0dXBfdGlwXCI6IFwiWC9Ud2l0dGVyLXNwZWNpZmljIHRpcCAodGhyZWFkIHN0cnVjdHVyZSwgY2hhcmFjdGVyIGNvdW50LCBldGMuKVwiXG4gIH1cbn1cblxuUnVsZXM6XG4tIFRoZSBKU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbi0gRG8gbm90IGluY2x1ZGUgYmFja3RpY2tzIG9yIGNvbW1lbnRzLlxuLSBUaWtUb2s6IEZvY3VzIG9uIFZJU1VBTCBIT09LUyBhbmQgZmFzdC1wYWNlZCBjb250ZW50LlxuLSBJbnN0YWdyYW06IEZvY3VzIG9uIEVOR0FHRU1FTlQgKGNvbW1lbnRzLCBzaGFyZXMsIHNhdmVzKS5cbi0gWDogRm9jdXMgb24gVklSQUwgVEVYVCBhbmQgc2hhcmVhYmlsaXR5LlxuLSBFYWNoIFwibWVhdFwiIE1VU1QgYmUgYW4gYXJyYXkgb2YgZXhhY3RseSAyIGJ1bGxldCBzdHJpbmdzLlxuLSBLZWVwIGFsbCBjb250ZW50IHBsYXRmb3JtLW9wdGltaXplZCBhbmQgYXV0aGVudGljLiR7YnJhbmRWb2ljZUluc3RydWN0aW9ufSR7Y29sbGVjdGl2ZUluc3RydWN0aW9ufWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSksXG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLmVycm9yPy5tZXNzYWdlIHx8XG4gICAgICAgICAgYEdlbWluaSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBkYXRhLmNhbmRpZGF0ZXM7XG4gICAgaWYgKCFjYW5kaWRhdGVzIHx8IGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBsYXRmb3JtLXNwZWNpZmljIGJsdWVwcmludHMgZ2VuZXJhdGVkIGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IGNhbmRpZGF0ZXNbMF0uY29udGVudD8ucGFydHM/LlswXT8udGV4dD8udHJpbSgpO1xuICAgIGlmICghdGV4dENvbnRlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBHZW1pbmkgQVBJLicpO1xuICAgIH1cblxuICAgIGxldCBwYXJzZWQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgSlNPTiBmcm9tIG1hcmtkb3duIGNvZGUgYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGNvbnN0IGpzb25NYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKC9cXHtbXFxzXFxTXSpcXH0vKTtcbiAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZSh0ZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBwbGF0Zm9ybS1zcGVjaWZpYyBibHVlcHJpbnRzIEpTT04gZnJvbSBHZW1pbmkgcmVzcG9uc2UuJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgc3RydWN0dXJlXG4gICAgaWYgKFxuICAgICAgIXBhcnNlZCB8fFxuICAgICAgIXBhcnNlZC50aWt0b2sgfHxcbiAgICAgICFwYXJzZWQuaW5zdGFncmFtIHx8XG4gICAgICAhcGFyc2VkLnggfHxcbiAgICAgIHR5cGVvZiBwYXJzZWQudGlrdG9rLmhvb2sgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcGFyc2VkLmluc3RhZ3JhbS5ob29rICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHBhcnNlZC54Lmhvb2sgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYXRmb3JtLXNwZWNpZmljIGJsdWVwcmludHMgSlNPTiBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy4nKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBlYWNoIHBsYXRmb3JtIGJsdWVwcmludFxuICAgIGNvbnN0IHBsYXRmb3JtczogKCd0aWt0b2snIHwgJ2luc3RhZ3JhbScgfCAneCcpW10gPSBbJ3Rpa3RvaycsICdpbnN0YWdyYW0nLCAneCddO1xuICAgIGZvciAoY29uc3QgcGxhdGZvcm0gb2YgcGxhdGZvcm1zKSB7XG4gICAgICBjb25zdCBibHVlcHJpbnQgPSBwYXJzZWRbcGxhdGZvcm1dO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgYmx1ZXByaW50Lmhvb2sgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBibHVlcHJpbnQuY3RhICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgYmx1ZXByaW50LnNldHVwX3RpcCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoYmx1ZXByaW50Lm1lYXQpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3BsYXRmb3JtfSBibHVlcHJpbnQgaXMgbWlzc2luZyByZXF1aXJlZCBmaWVsZHMuYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lYXRBcnJheSA9IGJsdWVwcmludC5tZWF0XG4gICAgICAgIC5maWx0ZXIoKGl0ZW06IGFueSkgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICYmIGl0ZW0udHJpbSgpLmxlbmd0aCA+IDApXG4gICAgICAgIC5zbGljZSgwLCAyKTtcblxuICAgICAgaWYgKG1lYXRBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtwbGF0Zm9ybX0gYmx1ZXByaW50IG11c3QgY29udGFpbiBhdCBsZWFzdCB0d28gbWVhdCBidWxsZXQgcG9pbnRzLmApO1xuICAgICAgfVxuXG4gICAgICBwYXJzZWRbcGxhdGZvcm1dID0ge1xuICAgICAgICBob29rOiBibHVlcHJpbnQuaG9vay50cmltKCksXG4gICAgICAgIG1lYXQ6IG1lYXRBcnJheS5tYXAoKG06IHN0cmluZykgPT4gbS50cmltKCkpLFxuICAgICAgICBjdGE6IGJsdWVwcmludC5jdGEudHJpbSgpLFxuICAgICAgICBzZXR1cF90aXA6IGJsdWVwcmludC5zZXR1cF90aXAudHJpbSgpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkIGFzIFBsYXRmb3JtU3BlY2lmaWNCbHVlcHJpbnRzO1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnR0VNSU5JX0FQSV9LRVknKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnI/Lm1lc3NhZ2UgfHxcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBwbGF0Zm9ybS1zcGVjaWZpYyBibHVlcHJpbnRzLiBQbGVhc2UgY2hlY2sgeW91ciBBUEkga2V5IGFuZCB0cnkgYWdhaW4uJ1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUHJvZmlsZUltYWdlKFxuICBpbnB1dDogR2VuZXJhdGVQcm9maWxlSW1hZ2VJbnB1dFxuKTogUHJvbWlzZTxQcm9maWxlSW1hZ2VSZXN1bHQ+IHtcbiAgY29uc3QgeyBuaWNoZSwgdmliZSwgcmVmaW5lUHJvbXB0IH0gPSBpbnB1dDtcblxuICBpZiAoIW5pY2hlLnRyaW0oKSB8fCAhdmliZS50cmltKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzaGFyZSB5b3VyIG5pY2hlIGFuZCB2aWJlIGZpcnN0LicpO1xuICB9XG5cbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XG5cbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR0VNSU5JX0FQSV9LRVkgaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgR0VNSU5JX0FQSV9LRVkgaW4geW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJ1xuICAgICk7XG4gIH1cblxuICBjb25zdCByZWZpbmVJbnN0cnVjdGlvbiA9IHJlZmluZVByb21wdD8udHJpbSgpIFxuICAgID8gYFxcblxcbklNUE9SVEFOVCBSRUZJTkVNRU5UOiBUaGUgdXNlciB3YW50cyB0byByZWZpbmUgdGhpcyBpbWFnZSB3aXRoOiBcIiR7cmVmaW5lUHJvbXB0LnRyaW0oKX1cIi4gSW5jb3Jwb3JhdGUgdGhpcyByZWZpbmVtZW50IGludG8gdGhlIHByb21wdC5gXG4gICAgOiAnJztcblxuICB0cnkge1xuICAgIC8vIEdlbmVyYXRlIGEgdGV4dC10by1pbWFnZSBwcm9tcHQgdXNpbmcgR2VtaW5pXG4gICAgY29uc3QgcHJvbXB0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBDcmVhdGUgYSBkZXRhaWxlZCwgcHJvZmVzc2lvbmFsIHByb21wdCBmb3IgZ2VuZXJhdGluZyBhIHByb2ZpbGUgcGljdHVyZSBmb3IgYSBzb2NpYWwgbWVkaWEgY3JlYXRvci4gVGhlIGNyZWF0b3IncyBuaWNoZSBpcyBcIiR7bmljaGUudHJpbSgpfVwiIGFuZCB0aGVpciB2aWJlIGlzIFwiJHt2aWJlLnRyaW0oKX1cIi4ke3JlZmluZUluc3RydWN0aW9ufVxuXG5SZXR1cm4gYSBTSU5HTEUgSlNPTiBvYmplY3Qgd2l0aCB0aGlzIGV4YWN0IHNoYXBlOlxue1xuICBcInByb21wdFwiOiBcImRldGFpbGVkIGltYWdlIGdlbmVyYXRpb24gcHJvbXB0IGRlc2NyaWJpbmcgYSBwcm9mZXNzaW9uYWwsIG1vZGVybiBwcm9maWxlIHBpY3R1cmUgdGhhdCBtYXRjaGVzIHRoZSBuaWNoZSBhbmQgdmliZVwiXG59XG5cblRoZSBwcm9tcHQgc2hvdWxkIGRlc2NyaWJlOlxuLSBQcm9mZXNzaW9uYWwgaGVhZHNob3Qgc3R5bGVcbi0gQ29sb3JzIGFuZCBtb29kIHRoYXQgbWF0Y2ggdGhlIHZpYmVcbi0gU3VidGxlIGVsZW1lbnRzIHRoYXQgaGludCBhdCB0aGUgbmljaGVcbi0gQ2xlYW4sIG1vZGVybiBhZXN0aGV0aWMgc3VpdGFibGUgZm9yIHNvY2lhbCBtZWRpYSBwcm9maWxlc1xuLSBIaWdoIHF1YWxpdHksIHByb2Zlc3Npb25hbCBwaG90b2dyYXBoeSBzdHlsZSR7cmVmaW5lUHJvbXB0Py50cmltKCkgPyAnXFxuLSBJbmNvcnBvcmF0ZSB0aGUgdXNlclxcJ3MgcmVmaW5lbWVudCByZXF1ZXN0cycgOiAnJ31cblxuUmV0dXJuIE9OTFkgdGhlIEpTT04sIG5vIG90aGVyIHRleHQuYCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFwcm9tcHRSZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcHJvbXB0UmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBgR2VtaW5pIEFQSSBlcnJvcjogJHtwcm9tcHRSZXNwb25zZS5zdGF0dXN9ICR7cHJvbXB0UmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21wdERhdGEgPSBhd2FpdCBwcm9tcHRSZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgcHJvbXB0Q2FuZGlkYXRlcyA9IHByb21wdERhdGEuY2FuZGlkYXRlcztcbiAgICBpZiAoIXByb21wdENhbmRpZGF0ZXMgfHwgcHJvbXB0Q2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvbXB0IGdlbmVyYXRlZCBmcm9tIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbXB0VGV4dCA9IHByb21wdENhbmRpZGF0ZXNbMF0uY29udGVudD8ucGFydHM/LlswXT8udGV4dD8udHJpbSgpO1xuICAgIGlmICghcHJvbXB0VGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZFByb21wdDogYW55O1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gZXh0cmFjdCBKU09OIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCBqc29uTWF0Y2ggPSBwcm9tcHRUZXh0Lm1hdGNoKC9cXHtbXFxzXFxTXSpcXH0vKTtcbiAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgcGFyc2VkUHJvbXB0ID0gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkUHJvbXB0ID0geyBwcm9tcHQ6IHByb21wdFRleHQgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHBhcnNlZFByb21wdCA9IHsgcHJvbXB0OiBwcm9tcHRUZXh0IH07XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VQcm9tcHQgPSBwYXJzZWRQcm9tcHQucHJvbXB0IHx8IHByb21wdFRleHQ7XG5cbiAgICAvLyBGb3Igbm93LCBzaW11bGF0ZSBpbWFnZSBnZW5lcmF0aW9uIGJ5IGNyZWF0aW5nIGEgZGF0YSBVUkwgcGxhY2Vob2xkZXJcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCByZXBsYWNlIHRoaXMgd2l0aCBhIHJlYWwgaW1hZ2UgZ2VuZXJhdGlvbiBBUEkgY2FsbCAoZS5nLiwgREFMTC1FLCBTdGFibGUgRGlmZnVzaW9uLCBldGMuKVxuICAgIC8vIEV4YW1wbGU6IGNvbnN0IGltYWdlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9pbWFnZXMvZ2VuZXJhdGlvbnMnLCB7Li4ufSk7XG4gICAgXG4gICAgLy8gU2ltdWxhdGVkIGltYWdlIFVSTCAtIHJlcGxhY2Ugd2l0aCBhY3R1YWwgaW1hZ2UgZ2VuZXJhdGlvbiBBUEkgY2FsbFxuICAgIGNvbnN0IHNpbXVsYXRlZEltYWdlVXJsID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKFxuICAgICAgYDxzdmcgd2lkdGg9XCI0MDBcIiBoZWlnaHQ9XCI0MDBcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgIDxyZWN0IHdpZHRoPVwiNDAwXCIgaGVpZ2h0PVwiNDAwXCIgZmlsbD1cIiMxZTI5M2JcIi8+XG4gICAgICAgIDxjaXJjbGUgY3g9XCIyMDBcIiBjeT1cIjE4MFwiIHI9XCI2MFwiIGZpbGw9XCIjZjU5ZTBiXCIgb3BhY2l0eT1cIjAuM1wiLz5cbiAgICAgICAgPHRleHQgeD1cIjIwMFwiIHk9XCIyODBcIiBmb250LWZhbWlseT1cIkFyaWFsXCIgZm9udC1zaXplPVwiMTZcIiBmaWxsPVwiI2Y1OWUwYlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+UHJvZmlsZSBJbWFnZTwvdGV4dD5cbiAgICAgICAgPHRleHQgeD1cIjIwMFwiIHk9XCIzMDBcIiBmb250LWZhbWlseT1cIkFyaWFsXCIgZm9udC1zaXplPVwiMTJcIiBmaWxsPVwiIzk0YTNiOFwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+JHtuaWNoZS50cmltKCl9PC90ZXh0PlxuICAgICAgPC9zdmc+YFxuICAgICl9YDtcblxuICAgIHJldHVybiB7XG4gICAgICBpbWFnZVVybDogc2ltdWxhdGVkSW1hZ2VVcmwsXG4gICAgICBwcm9tcHQ6IGltYWdlUHJvbXB0LFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdHRU1JTklfQVBJX0tFWScpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycj8ubWVzc2FnZSB8fFxuICAgICAgICAnRmFpbGVkIHRvIGdlbmVyYXRlIHByb2ZpbGUgaW1hZ2UuIFBsZWFzZSBjaGVjayB5b3VyIEFQSSBrZXkgYW5kIHRyeSBhZ2Fpbi4nXG4gICAgKTtcbiAgfVxufVxuXG50eXBlIEdlbmVyYXRlTGlicmFyaWFuSW5zaWdodElucHV0ID0ge1xuICBzYXZlZElkZWFzOiBzdHJpbmdbXTtcbiAgdXNlck5hbWU/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVMaWJyYXJpYW5JbnNpZ2h0KFxuICBpbnB1dDogR2VuZXJhdGVMaWJyYXJpYW5JbnNpZ2h0SW5wdXRcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHsgc2F2ZWRJZGVhcywgdXNlck5hbWUgfSA9IGlucHV0O1xuXG4gIGlmICghc2F2ZWRJZGVhcyB8fCBzYXZlZElkZWFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc2F2ZWQgaWRlYXMgdG8gYW5hbHl6ZS4nKTtcbiAgfVxuXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZO1xuXG4gIGlmICghYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0dFTUlOSV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2Ugc2V0IEdFTUlOSV9BUElfS0VZIGluIHlvdXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLidcbiAgICApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBpZGVhc1RleHQgPSBzYXZlZElkZWFzXG4gICAgICAubWFwKChpZGVhLCBpZHgpID0+IGAke2lkeCArIDF9LiAke2lkZWF9YClcbiAgICAgIC5qb2luKCdcXG4nKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktMS41LWZsYXNoOmdlbmVyYXRlQ29udGVudD9rZXk9JHthcGlLZXl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBgWW91IGFyZSB0aGUgQWN0aXZlIExpYnJhcmlhbiwgYW4gQUkgVGFsZW50IE1hbmFnZXIgYW5hbHl6aW5nIGEgY3JlYXRvcidzIGNvbnRlbnQgbGlicmFyeS5cblxuVGhlIGNyZWF0b3Ike3VzZXJOYW1lID8gYCwgJHt1c2VyTmFtZX0sYCA6ICcnfSBoYXMgc2F2ZWQgJHtzYXZlZElkZWFzLmxlbmd0aH0gdmlkZW8gaWRlYXM6XG5cbiR7aWRlYXNUZXh0fVxuXG5BbmFseXplIHRoZXNlIGlkZWFzIGFuZCBwcm92aWRlIGEgY29uY2lzZSwgYWN0aW9uYWJsZSBpbnNpZ2h0ICgyLTMgc2VudGVuY2VzIG1heCkgdGhhdDpcbjEuIElkZW50aWZpZXMgdGhlaXIgc3Ryb25nZXN0IGNvbnRlbnQgcGlsbGFyIG9yIHRoZW1lXG4yLiBQcm92aWRlcyBzcGVjaWZpYywgYWN0aW9uYWJsZSBndWlkYW5jZSBvbiB3aGF0IHRvIGRvIG1vcmUgb2ZcblxuRm9ybWF0OiBBZGRyZXNzIHRoZW0gYnkgbmFtZSBpZiBwcm92aWRlZCwgdGhlbiBnaXZlIHRoZSBpbnNpZ2h0LiBFeGFtcGxlOiBcIiR7dXNlck5hbWUgfHwgJ1lvdXInfSwgeW91ciBnYXJkZW5pbmcgdGlwcyBhcmUgeW91ciBzdHJvbmdlc3QgcGlsbGFyLiBMZXQncyBkbyBtb3JlIG9mIHRob3NlLlwiXG5cblJldHVybiBPTkxZIHRoZSBpbnNpZ2h0IHRleHQsIG5vIGV4dHJhIGZvcm1hdHRpbmcgb3IgZXhwbGFuYXRpb24uYCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBgR2VtaW5pIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGRhdGEuY2FuZGlkYXRlcztcbiAgICBpZiAoIWNhbmRpZGF0ZXMgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5zaWdodCBnZW5lcmF0ZWQgZnJvbSBHZW1pbmkgQVBJLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHRDb250ZW50ID0gY2FuZGlkYXRlc1swXS5jb250ZW50Py5wYXJ0cz8uWzBdPy50ZXh0Py50cmltKCk7XG4gICAgaWYgKCF0ZXh0Q29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnR0VNSU5JX0FQSV9LRVknKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnI/Lm1lc3NhZ2UgfHxcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBsaWJyYXJpYW4gaW5zaWdodC4gUGxlYXNlIGNoZWNrIHlvdXIgQVBJIGtleSBhbmQgdHJ5IGFnYWluLidcbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIkdFTUlOSV9BUElfS0VZIiwiY29uc29sZSIsIndhcm4iLCJnZXRVc2VyQ29udGVudEhpc3RvcnkiLCJ1c2VySWQiLCJzdXBhYmFzZSIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm1heWJlU2luZ2xlIiwiY29udGVudF90ZXh0IiwiZ2V0Q29sbGVjdGl2ZUludGVsbGlnZW5jZSIsIk9iamVjdCIsInBlcmZvcm1hbmNlcyIsInBlcmZFcnJvciIsImluIiwibGltaXQiLCJsZW5ndGgiLCJjb250ZXh0IiwidmlyYWxDb3VudCIsInN1Y2Nlc3NDb3VudCIsImRvbWluYW50VmliZSIsInZpcmFsUG90ZW50aWFsIiwiYmx1ZXByaW50SWRzIiwibWFwIiwicCIsImJsdWVwcmludF9pZCIsImZpbHRlciIsInN0YXR1cyIsImJsdWVwcmludHMiLCJibHVlcHJpbnRFcnJvciIsInRvdGFsIiwiTWF0aCIsInJvdW5kIiwidmlyYWxCbHVlcHJpbnRJZHMiLCJ2aXJhbEJwcyIsImJwIiwiaW5jbHVkZXMiLCJpZCIsInZpYmVXb3JkcyIsImZvckVhY2giLCJob29rIiwiYmx1ZXByaW50IiwidGlrdG9rIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImVudHJpZXMiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsImlkeCIsInBlcmYiLCJmaW5kIiwiaWRlYSIsInRvVXBwZXJDYXNlIiwiZ2VuZXJhdGVCaW9zIiwiaW5wdXQiLCJuaWNoZSIsInZpYmUiLCJ0cmltIiwiRXJyb3IiLCJhcGlLZXkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJicmFuZFZvaWNlIiwiYnJhbmRWb2ljZUluc3RydWN0aW9uIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnRlbnRzIiwicGFydHMiLCJ0ZXh0Iiwib2siLCJqc29uIiwidGV4dENvbnRlbnQiLCJjYW5kaWRhdGVzIiwiY29udGVudCIsImJpb3MiLCJzcGxpdCIsImxpbmUiLCJtYXRjaCIsImVyciIsImdlbmVyYXRlVmlzaW9uQmlvcyIsInZpc2lvbiIsImF1dGhvcml0eSIsInJlbGF0YWJpbGl0eSIsIm15c3RlcnkiLCJqc29uTWF0Y2giLCJwYXJzZWQiLCJwYXJzZSIsImdlbmVyYXRlQnJhbmRCcmllZiIsIm5hbWVPcHRpb25zIiwiY29udGVudEhpc3RvcnkiLCJjb250ZXh0SW5zdHJ1Y3Rpb24iLCJBcnJheSIsImlzQXJyYXkiLCJnZW5lcmF0ZVZpZGVvSWRlYXMiLCJjb2xsZWN0aXZlSW50ZWxsaWdlbmNlIiwiY29sbGVjdGl2ZUluc3RydWN0aW9uIiwiZXJyb3JEYXRhIiwiY2F0Y2giLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsImlkZWFzIiwicmVwbGFjZSIsInRyaW1tZWQiLCJwdXNoIiwiZ2VuZXJhdGVWaWRlb0JsdWVwcmludCIsImN0YSIsInNldHVwX3RpcCIsIm1lYXQiLCJtZWF0QXJyYXkiLCJpdGVtIiwibSIsImdlbmVyYXRlUGxhdGZvcm1TcGVjaWZpY0JsdWVwcmludHMiLCJpbnN0YWdyYW0iLCJ4IiwicGxhdGZvcm1zIiwicGxhdGZvcm0iLCJnZW5lcmF0ZVByb2ZpbGVJbWFnZSIsInJlZmluZVByb21wdCIsInJlZmluZUluc3RydWN0aW9uIiwicHJvbXB0Q2FuZGlkYXRlcyIsInByb21wdFJlc3BvbnNlIiwicHJvbXB0RGF0YSIsInByb21wdFRleHQiLCJwYXJzZWRQcm9tcHQiLCJwcm9tcHQiLCJpbWFnZVByb21wdCIsInNpbXVsYXRlZEltYWdlVXJsIiwiYnRvYSIsImltYWdlVXJsIiwiZ2VuZXJhdGVMaWJyYXJpYW5JbnNpZ2h0Iiwic2F2ZWRJZGVhcyIsInVzZXJOYW1lIiwiaWRlYXNUZXh0Iiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/gemini.ts\n"));

/***/ })

});