"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/identity/page",{

/***/ "(app-pages-browser)/./lib/gemini.ts":
/*!***********************!*\
  !*** ./lib/gemini.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateBios: function() { return /* binding */ generateBios; },\n/* harmony export */   generateBrandBrief: function() { return /* binding */ generateBrandBrief; },\n/* harmony export */   generateLibrarianInsight: function() { return /* binding */ generateLibrarianInsight; },\n/* harmony export */   generatePlatformSpecificBlueprints: function() { return /* binding */ generatePlatformSpecificBlueprints; },\n/* harmony export */   generateProfileImage: function() { return /* binding */ generateProfileImage; },\n/* harmony export */   generateVideoBlueprint: function() { return /* binding */ generateVideoBlueprint; },\n/* harmony export */   generateVideoIdeas: function() { return /* binding */ generateVideoIdeas; },\n/* harmony export */   generateVisionBios: function() { return /* binding */ generateVisionBios; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Verify GEMINI_API_KEY on module load\nif (typeof process !== \"undefined\" && !process.env.GEMINI_API_KEY) {\n    console.warn(\"⚠️ WARNING: GEMINI_API_KEY is not set in environment variables. AI features will not work.\");\n}\n// Helper function to fetch user content history for brand voice training\nasync function getUserContentHistory(userId) {\n    if (!userId) return null;\n    try {\n        const { supabase } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\"));\n        const { data, error } = await supabase.from(\"user_content_history\").select(\"content_text\").eq(\"user_id\", userId).maybeSingle();\n        if (error || !(data === null || data === void 0 ? void 0 : data.content_text)) {\n            return null;\n        }\n        return data.content_text;\n    } catch (e) {\n        return null;\n    }\n}\n// Helper function to fetch collective intelligence from viral/successful blueprints\n// Returns both context string and metadata for strategy notes\nasync function getCollectiveIntelligence() {\n    try {\n        var _Object_entries_sort_;\n        const { supabase } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\"));\n        // Fetch blueprints marked as viral or success from blueprint_performance\n        const { data: performances, error: perfError } = await supabase.from(\"blueprint_performance\").select(\"blueprint_id, status\").in(\"status\", [\n            \"viral\",\n            \"success\"\n        ]).limit(50);\n        if (perfError || !performances || performances.length === 0) {\n            return {\n                context: null,\n                viralCount: 0,\n                successCount: 0,\n                dominantVibe: null,\n                viralPotential: null\n            };\n        }\n        const blueprintIds = performances.map((p)=>p.blueprint_id);\n        const viralCount = performances.filter((p)=>p.status === \"viral\").length;\n        const successCount = performances.filter((p)=>p.status === \"success\").length;\n        // Fetch the actual blueprint data\n        const { data: blueprints, error: blueprintError } = await supabase.from(\"saved_blueprints\").select(\"idea, blueprint\").in(\"id\", blueprintIds);\n        if (blueprintError || !blueprints || blueprints.length === 0) {\n            return {\n                context: null,\n                viralCount,\n                successCount,\n                dominantVibe: null,\n                viralPotential: null\n            };\n        }\n        // Calculate viral potential percentage (simplified: viralCount / total * 100)\n        const total = performances.length;\n        const viralPotential = total > 0 ? Math.round(viralCount / total * 100) : null;\n        // Extract dominant vibes from viral blueprints\n        const viralBlueprintIds = performances.filter((p)=>p.status === \"viral\").map((p)=>p.blueprint_id);\n        const viralBps = blueprints.filter((bp)=>viralBlueprintIds.includes(bp.id));\n        // Simple vibe extraction from hooks\n        const vibeWords = {};\n        viralBps.forEach((bp)=>{\n            var _bp_blueprint_tiktok;\n            const hook = typeof bp.blueprint === \"object\" && bp.blueprint !== null ? (\"tiktok\" in bp.blueprint ? (_bp_blueprint_tiktok = bp.blueprint.tiktok) === null || _bp_blueprint_tiktok === void 0 ? void 0 : _bp_blueprint_tiktok.hook : \"hook\" in bp.blueprint ? bp.blueprint.hook : \"\") || \"\" : \"\";\n            const lower = hook.toLowerCase();\n            if (lower.includes(\"quick\") || lower.includes(\"fast\")) vibeWords[\"urgent\"] = (vibeWords[\"urgent\"] || 0) + 1;\n            if (lower.includes(\"secret\") || lower.includes(\"hidden\")) vibeWords[\"mysterious\"] = (vibeWords[\"mysterious\"] || 0) + 1;\n            if (lower.includes(\"never\") || lower.includes(\"stop\")) vibeWords[\"bold\"] = (vibeWords[\"bold\"] || 0) + 1;\n            if (lower.includes(\"simple\") || lower.includes(\"easy\")) vibeWords[\"accessible\"] = (vibeWords[\"accessible\"] || 0) + 1;\n            if (lower.includes(\"proven\") || lower.includes(\"tested\")) vibeWords[\"confident\"] = (vibeWords[\"confident\"] || 0) + 1;\n        });\n        const dominantVibe = ((_Object_entries_sort_ = Object.entries(vibeWords).sort((a, b)=>b[1] - a[1])[0]) === null || _Object_entries_sort_ === void 0 ? void 0 : _Object_entries_sort_[0]) || null;\n        // Create collective intelligence context\n        let context = \"GLOBAL CONTEXT: The Octane Nexus community has marked \".concat(viralCount + successCount, \" blueprints as successful (\").concat(viralCount, \" viral, \").concat(successCount, \" successful). Study these proven patterns:\\n\\n\");\n        blueprints.slice(0, 20).forEach((bp, idx)=>{\n            const perf = performances.find((p)=>p.blueprint_id === bp.id);\n            if (bp.idea) {\n                var _perf_status;\n                context += \"\".concat(idx + 1, \". [\").concat((perf === null || perf === void 0 ? void 0 : (_perf_status = perf.status) === null || _perf_status === void 0 ? void 0 : _perf_status.toUpperCase()) || \"SUCCESS\", \"] \").concat(bp.idea, \"\\n\");\n            }\n        });\n        context += \"\\nUse these community-validated patterns to inform your content generation. These ideas have proven to resonate with real audiences.\";\n        return {\n            context,\n            viralCount,\n            successCount,\n            dominantVibe,\n            viralPotential: viralPotential && viralPotential > 0 ? viralPotential : null\n        };\n    } catch (e) {\n        return {\n            context: null,\n            viralCount: 0,\n            successCount: 0,\n            dominantVibe: null,\n            viralPotential: null\n        };\n    }\n}\n// This utility is the single place where we talk to Gemini.\n// Right now it returns mocked bios so you can work without an API key.\n// Later, replace the internals with a real Gemini API call.\nasync function generateBios(input) {\n    const { niche, vibe } = input;\n    if (!niche.trim() || !vibe.trim()) {\n        throw new Error(\"Please share your niche and vibe first.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        // Simulated latency so the UI can show a loading state.\n        await new Promise((resolve)=>setTimeout(resolve, 900));\n        return [\n            \"Helping you grow as a \".concat(niche.trim(), \" creator with a \").concat(vibe.trim(), \" twist. Easy tips, real results.\"),\n            \"Your go-to \".concat(niche.trim(), \" corner on the internet. \").concat(vibe.trim(), \" stories, simple playbooks, steady growth.\"),\n            \"Building a \".concat(vibe.trim(), \" space for \").concat(niche.trim(), \" lovers. Clear ideas, smart posts, and steady momentum.\")\n        ];\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = input.userId ? await getUserContentHistory(input.userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT: Study this creator's successful past content and match their voice, tone, and style:\\n\\n\".concat(brandVoice, \"\\n\\nGenerate bios that sound authentically like this creator wrote them.\") : \"\";\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Create 3 short, SEO-friendly social media bios for a \".concat(niche.trim(), ' creator with a \"').concat(vibe.trim(), '\" style. Each bio should be:\\n- Under 150 characters\\n- No hashtags\\n- Professional yet authentic\\n- Clear value proposition\\n\\nReturn each bio as a separate line.').concat(brandVoiceInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Gemini API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        const textContent = (_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text;\n        if (textContent) {\n            const bios = textContent.split(/\\n+/).map((line)=>line.trim()).filter((line)=>line.length > 0 && !line.match(/^(bio|option)\\s*\\d*:?\\s*$/i)).slice(0, 3);\n            if (bios.length >= 3) {\n                return bios;\n            }\n        }\n        // Fallback to mock bios\n        return [\n            \"Helping you grow as a \".concat(niche.trim(), \" creator with a \").concat(vibe.trim(), \" twist. Easy tips, real results.\"),\n            \"Your go-to \".concat(niche.trim(), \" corner on the internet. \").concat(vibe.trim(), \" stories, simple playbooks, steady growth.\"),\n            \"Building a \".concat(vibe.trim(), \" space for \").concat(niche.trim(), \" lovers. Clear ideas, smart posts, and steady momentum.\")\n        ];\n    } catch (err) {\n        console.error(\"Error generating bios:\", err);\n        // Return mock bios on error\n        return [\n            \"Helping you grow as a \".concat(niche.trim(), \" creator with a \").concat(vibe.trim(), \" twist. Easy tips, real results.\"),\n            \"Your go-to \".concat(niche.trim(), \" corner on the internet. \").concat(vibe.trim(), \" stories, simple playbooks, steady growth.\"),\n            \"Building a \".concat(vibe.trim(), \" space for \").concat(niche.trim(), \" lovers. Clear ideas, smart posts, and steady momentum.\")\n        ];\n    }\n}\nasync function generateVisionBios(input) {\n    const { vision, userId } = input;\n    if (!vision.trim()) {\n        throw new Error(\"Please share your vision first.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        console.warn(\"GEMINI_API_KEY not set, returning mock vision bios\");\n        await new Promise((resolve)=>setTimeout(resolve, 1200));\n        return {\n            authority: \"Expert insights and proven strategies for creators who want to build real authority.\",\n            relatability: \"Real talk from someone who's been there. No fluff, just honest stories and practical advice.\",\n            mystery: \"Behind the scenes of building something different. Join the journey.\"\n        };\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT: Study this creator's successful past content and match their voice:\\n\\n\".concat(brandVoice, \"\\n\\n\") : \"\";\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Based on this creator's vision, generate 3 high-detail social media bios:\\n\\nVision: \\\"\".concat(vision.trim(), '\"\\n\\nCreate:\\n1. AUTHORITY BIO: Position them as an expert with credentials, results, and credibility. Make it commanding and impressive.\\n2. RELATABILITY BIO: Make them feel like a friend who gets it. Show vulnerability, real experiences, and approachability.\\n3. MYSTERY BIO: Create intrigue and curiosity. Hint at something special without revealing everything.\\n\\nEach bio should be 120-150 characters, no hashtags, authentic to their voice.').concat(brandVoiceInstruction, '\\n\\nReturn as JSON:\\n{\\n  \"authority\": \"bio text here\",\\n  \"relatability\": \"bio text here\",\\n  \"mystery\": \"bio text here\"\\n}')\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Gemini API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        const textContent = (_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text;\n        if (textContent) {\n            // Try to parse JSON from response\n            const jsonMatch = textContent.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                try {\n                    const parsed = JSON.parse(jsonMatch[0]);\n                    if (parsed.authority && parsed.relatability && parsed.mystery) {\n                        return parsed;\n                    }\n                } catch (e) {\n                // Fall through to fallback\n                }\n            }\n        }\n        // Fallback to mock bios\n        return {\n            authority: \"Expert insights and proven strategies for creators who want to build real authority.\",\n            relatability: \"Real talk from someone who's been there. No fluff, just honest stories and practical advice.\",\n            mystery: \"Behind the scenes of building something different. Join the journey.\"\n        };\n    } catch (err) {\n        console.error(\"Error generating vision bios:\", err);\n        return {\n            authority: \"Expert insights and proven strategies for creators who want to build real authority.\",\n            relatability: \"Real talk from someone who's been there. No fluff, just honest stories and practical advice.\",\n            mystery: \"Behind the scenes of building something different. Join the journey.\"\n        };\n    }\n}\nasync function generateBrandBrief(input) {\n    const { userId, vision } = input;\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        console.warn(\"GEMINI_API_KEY not set, returning mock brand brief\");\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        return {\n            niche: \"content creation\",\n            vibe: \"confident\",\n            nameOptions: [\n                \"creator\",\n                \"builder\",\n                \"maker\",\n                \"studio\",\n                \"lab\"\n            ]\n        };\n    }\n    // Fetch user's content history for context\n    const contentHistory = userId ? await getUserContentHistory(userId) : null;\n    const contextInstruction = contentHistory ? \"\\n\\nUser's previous content context:\\n\".concat(contentHistory, \"\\n\\nUse this to inform niche and vibe suggestions.\") : \"\";\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'Analyze the user\\'s context and suggest:\\n1. A specific niche (e.g., \"fitness for busy parents\", \"crypto education\", \"book reviews\")\\n2. A vibe/voice (e.g., \"confident\", \"playful\", \"calm\", \"bold\", \"authentic\")\\n3. Five name/handle options (short, memorable, brandable)\\n\\n'.concat(contextInstruction, '\\n\\nReturn as JSON:\\n{\\n  \"niche\": \"specific niche description\",\\n  \"vibe\": \"voice descriptor\",\\n  \"nameOptions\": [\"option1\", \"option2\", \"option3\", \"option4\", \"option5\"]\\n}')\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Gemini API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        const textContent = (_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text;\n        if (textContent) {\n            const jsonMatch = textContent.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                try {\n                    const parsed = JSON.parse(jsonMatch[0]);\n                    if (parsed.niche && parsed.vibe && Array.isArray(parsed.nameOptions)) {\n                        return parsed;\n                    }\n                } catch (e) {\n                // Fall through to fallback\n                }\n            }\n        }\n        // Fallback\n        return {\n            niche: \"content creation\",\n            vibe: \"confident\",\n            nameOptions: [\n                \"creator\",\n                \"builder\",\n                \"maker\",\n                \"studio\",\n                \"lab\"\n            ]\n        };\n    } catch (err) {\n        console.error(\"Error generating brand brief:\", err);\n        return {\n            niche: \"content creation\",\n            vibe: \"confident\",\n            nameOptions: [\n                \"creator\",\n                \"builder\",\n                \"maker\",\n                \"studio\",\n                \"lab\"\n            ]\n        };\n    }\n}\nasync function generateVideoIdeas(input) {\n    const { niche, userId } = input;\n    if (!niche.trim()) {\n        throw new Error(\"Please share your niche first so we can aim the ideas.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT: Study this creator's successful past content and match their voice, tone, and style:\\n\\n\".concat(brandVoice, \"\\n\\nGenerate ideas that sound authentically like this creator wrote them.\") : \"\";\n    // Fetch collective intelligence from viral/successful blueprints\n    const collectiveIntelligence = await getCollectiveIntelligence();\n    const collectiveInstruction = collectiveIntelligence.context ? \"\\n\\n\".concat(collectiveIntelligence.context) : \"\";\n    try {\n        var _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'Create 3 unique, filmable video script ideas for a social media creator in the \"'.concat(niche.trim(), '\" niche. Each idea should be:\\n- Specific and actionable\\n- Suitable for short-form video (30-60 seconds)\\n- Clear enough to film immediately\\n- Engaging and shareable\\n\\nReturn each idea as a separate, concise sentence. No numbering, no hashtags, just the idea itself.').concat(brandVoiceInstruction).concat(collectiveInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        // Extract text from Gemini response\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No ideas generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : _candidates__content_parts_.text;\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        // Parse the response into an array of ideas\n        // Gemini may return numbered or bulleted lists, or plain text with line breaks\n        const ideas = textContent.split(/\\n+/).map((line)=>line.trim()).filter((line)=>{\n            // Remove empty lines and common list markers\n            return line.length > 0 && !line.match(/^[\\d\\.\\)\\-•]\\s*$/) && !line.match(/^(idea|script|video)\\s*\\d*:?\\s*$/i);\n        }).map((line)=>{\n            // Remove leading numbers, bullets, dashes, etc.\n            return line.replace(/^[\\d\\.\\)\\-•]\\s+/, \"\").trim();\n        }).filter((line)=>line.length > 10) // Filter out very short lines\n        .slice(0, 3); // Take first 3 valid ideas\n        if (ideas.length === 0) {\n            throw new Error(\"Could not parse ideas from Gemini response.\");\n        }\n        // If we got fewer than 3, pad with fallback ideas\n        while(ideas.length < 3){\n            const trimmed = niche.trim();\n            ideas.push(\"Create a quick tutorial showing one essential \".concat(trimmed, \" technique in under 60 seconds.\"));\n        }\n        return ideas.slice(0, 3);\n    } catch (err) {\n        // If it's already our error, re-throw it\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        // For API errors, provide a helpful message\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate video ideas. Please check your API key and try again.\");\n    }\n}\nasync function generateVideoBlueprint(input) {\n    const { idea, userId } = input;\n    if (!idea.trim()) {\n        throw new Error(\"Please share an idea first so we can shape a blueprint.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT SYSTEM INSTRUCTION: Study this creator's successful past content and match their exact voice, tone, style, and structure:\\n\\n\".concat(brandVoice, \"\\n\\nWrite the blueprint in a way that sounds authentically like this creator wrote it.\") : \"\";\n    // Fetch collective intelligence from viral/successful blueprints\n    const collectiveIntelligence = await getCollectiveIntelligence();\n    const collectiveInstruction = collectiveIntelligence.context ? \"\\n\\n\".concat(collectiveIntelligence.context) : \"\";\n    try {\n        var _candidates__content_parts__text, _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'You are helping a creator film a short-form social video based on this idea: \"'.concat(idea.trim(), '\".\\n\\nReturn a SINGLE JSON object with this exact shape and nothing else:\\n{\\n  \"hook\": \"3-second opening line spoken on camera\",\\n  \"meat\": [\\n    \"first simple bullet point for the middle\",\\n    \"second simple bullet point for the middle\"\\n  ],\\n  \"cta\": \"clear closing call to action line\",\\n  \"setup_tip\": \"one tip on lighting or camera placement\"\\n}\\n\\nRules:\\n- The JSON must be valid and parseable.\\n- Do not include backticks or comments.\\n- \"meat\" MUST be an array of exactly 2 bullet strings.\\n- Keep each line short, concrete, and easy to film within 30–60 seconds.').concat(brandVoiceInstruction).concat(collectiveInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No blueprint generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : (_candidates__content_parts__text = _candidates__content_parts_.text) === null || _candidates__content_parts__text === void 0 ? void 0 : _candidates__content_parts__text.trim();\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        let parsed;\n        try {\n            parsed = JSON.parse(textContent);\n        } catch (e) {\n            throw new Error(\"Failed to parse blueprint JSON from Gemini response.\");\n        }\n        if (!parsed || typeof parsed.hook !== \"string\" || typeof parsed.cta !== \"string\" || typeof parsed.setup_tip !== \"string\" || !Array.isArray(parsed.meat)) {\n            throw new Error(\"Blueprint JSON is missing required fields.\");\n        }\n        const meatArray = parsed.meat.filter((item)=>typeof item === \"string\" && item.trim().length > 0).slice(0, 2);\n        if (meatArray.length < 2) {\n            throw new Error(\"Blueprint JSON must contain at least two meat bullet points.\");\n        }\n        const blueprint = {\n            hook: parsed.hook.trim(),\n            meat: meatArray.map((m)=>m.trim()),\n            cta: parsed.cta.trim(),\n            setup_tip: parsed.setup_tip.trim()\n        };\n        return blueprint;\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate a video blueprint. Please check your API key and try again.\");\n    }\n}\nasync function generatePlatformSpecificBlueprints(input) {\n    const { idea, userId } = input;\n    if (!idea.trim()) {\n        throw new Error(\"Please share an idea first so we can shape platform-specific blueprints.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    // Fetch user's brand voice if available\n    const brandVoice = userId ? await getUserContentHistory(userId) : null;\n    const brandVoiceInstruction = brandVoice ? \"\\n\\nIMPORTANT SYSTEM INSTRUCTION: Study this creator's successful past content and match their exact voice, tone, style, and structure:\\n\\n\".concat(brandVoice, \"\\n\\nWrite all three platform blueprints (TikTok, Instagram, X) in a way that sounds authentically like this creator wrote them.\") : \"\";\n    // Fetch collective intelligence from viral/successful blueprints\n    const collectiveIntelligence = await getCollectiveIntelligence();\n    const collectiveInstruction = collectiveIntelligence.context ? \"\\n\\n\".concat(collectiveIntelligence.context) : \"\";\n    try {\n        var _candidates__content_parts__text, _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: 'You are helping a creator turn this idea into three platform-specific scripts: \"'.concat(idea.trim(), '\".\\n\\nReturn a SINGLE JSON object with this exact shape and nothing else:\\n{\\n  \"tiktok\": {\\n    \"hook\": \"visual, attention-grabbing 3-second opening - focus on strong visual hooks\",\\n    \"meat\": [\\n      \"first key point optimized for TikTok\\'s fast-paced visual format\",\\n      \"second key point with high visual appeal\"\\n    ],\\n    \"cta\": \"clear call to action perfect for TikTok engagement\",\\n    \"setup_tip\": \"TikTok-specific setup tip (vertical format, trending sounds, etc.)\"\\n  },\\n  \"instagram\": {\\n    \"hook\": \"engaging opening line designed for Instagram\\'s engagement algorithm\",\\n    \"meat\": [\\n      \"first point optimized for Instagram Reels engagement\",\\n      \"second point with hashtag and engagement strategy\"\\n    ],\\n    \"cta\": \"call to action that encourages comments and shares\",\\n    \"setup_tip\": \"Instagram-specific setup tip (square/vertical format, trending audio, etc.)\"\\n  },\\n  \"x\": {\\n    \"hook\": \"viral-worthy text hook optimized for X/Twitter\\'s text-first format\",\\n    \"meat\": [\\n      \"first point as concise, shareable text\",\\n      \"second point designed to go viral with retweets\"\\n    ],\\n    \"cta\": \"clear call to action optimized for X engagement\",\\n    \"setup_tip\": \"X/Twitter-specific tip (thread structure, character count, etc.)\"\\n  }\\n}\\n\\nRules:\\n- The JSON must be valid and parseable.\\n- Do not include backticks or comments.\\n- TikTok: Focus on VISUAL HOOKS and fast-paced content.\\n- Instagram: Focus on ENGAGEMENT (comments, shares, saves).\\n- X: Focus on VIRAL TEXT and shareability.\\n- Each \"meat\" MUST be an array of exactly 2 bullet strings.\\n- Keep all content platform-optimized and authentic.').concat(brandVoiceInstruction).concat(collectiveInstruction)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No platform-specific blueprints generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : (_candidates__content_parts__text = _candidates__content_parts_.text) === null || _candidates__content_parts__text === void 0 ? void 0 : _candidates__content_parts__text.trim();\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        let parsed;\n        try {\n            // Try to extract JSON from markdown code blocks if present\n            const jsonMatch = textContent.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                parsed = JSON.parse(jsonMatch[0]);\n            } else {\n                parsed = JSON.parse(textContent);\n            }\n        } catch (e) {\n            throw new Error(\"Failed to parse platform-specific blueprints JSON from Gemini response.\");\n        }\n        // Validate structure\n        if (!parsed || !parsed.tiktok || !parsed.instagram || !parsed.x || typeof parsed.tiktok.hook !== \"string\" || typeof parsed.instagram.hook !== \"string\" || typeof parsed.x.hook !== \"string\") {\n            throw new Error(\"Platform-specific blueprints JSON is missing required fields.\");\n        }\n        // Validate each platform blueprint\n        const platforms = [\n            \"tiktok\",\n            \"instagram\",\n            \"x\"\n        ];\n        for (const platform of platforms){\n            const blueprint = parsed[platform];\n            if (typeof blueprint.hook !== \"string\" || typeof blueprint.cta !== \"string\" || typeof blueprint.setup_tip !== \"string\" || !Array.isArray(blueprint.meat)) {\n                throw new Error(\"\".concat(platform, \" blueprint is missing required fields.\"));\n            }\n            const meatArray = blueprint.meat.filter((item)=>typeof item === \"string\" && item.trim().length > 0).slice(0, 2);\n            if (meatArray.length < 2) {\n                throw new Error(\"\".concat(platform, \" blueprint must contain at least two meat bullet points.\"));\n            }\n            parsed[platform] = {\n                hook: blueprint.hook.trim(),\n                meat: meatArray.map((m)=>m.trim()),\n                cta: blueprint.cta.trim(),\n                setup_tip: blueprint.setup_tip.trim()\n            };\n        }\n        return parsed;\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate platform-specific blueprints. Please check your API key and try again.\");\n    }\n}\nasync function generateProfileImage(input) {\n    const { niche, vibe, refinePrompt } = input;\n    if (!niche.trim() || !vibe.trim()) {\n        throw new Error(\"Please share your niche and vibe first.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    const refineInstruction = (refinePrompt === null || refinePrompt === void 0 ? void 0 : refinePrompt.trim()) ? '\\n\\nIMPORTANT REFINEMENT: The user wants to refine this image with: \"'.concat(refinePrompt.trim(), '\". Incorporate this refinement into the prompt.') : \"\";\n    try {\n        var _promptCandidates__content_parts__text, _promptCandidates__content_parts_, _promptCandidates__content_parts, _promptCandidates__content;\n        // Generate a text-to-image prompt using Gemini\n        const promptResponse = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Create a detailed, professional prompt for generating a profile picture for a social media creator. The creator's niche is \\\"\".concat(niche.trim(), '\" and their vibe is \"').concat(vibe.trim(), '\".').concat(refineInstruction, '\\n\\nReturn a SINGLE JSON object with this exact shape:\\n{\\n  \"prompt\": \"detailed image generation prompt describing a professional, modern profile picture that matches the niche and vibe\"\\n}\\n\\nThe prompt should describe:\\n- Professional headshot style\\n- Colors and mood that match the vibe\\n- Subtle elements that hint at the niche\\n- Clean, modern aesthetic suitable for social media profiles\\n- High quality, professional photography style').concat((refinePrompt === null || refinePrompt === void 0 ? void 0 : refinePrompt.trim()) ? \"\\n- Incorporate the user's refinement requests\" : \"\", \"\\n\\nReturn ONLY the JSON, no other text.\")\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!promptResponse.ok) {\n            var _errorData_error;\n            const errorData = await promptResponse.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(promptResponse.status, \" \").concat(promptResponse.statusText));\n        }\n        const promptData = await promptResponse.json();\n        const promptCandidates = promptData.candidates;\n        if (!promptCandidates || promptCandidates.length === 0) {\n            throw new Error(\"No prompt generated from Gemini API.\");\n        }\n        const promptText = (_promptCandidates__content = promptCandidates[0].content) === null || _promptCandidates__content === void 0 ? void 0 : (_promptCandidates__content_parts = _promptCandidates__content.parts) === null || _promptCandidates__content_parts === void 0 ? void 0 : (_promptCandidates__content_parts_ = _promptCandidates__content_parts[0]) === null || _promptCandidates__content_parts_ === void 0 ? void 0 : (_promptCandidates__content_parts__text = _promptCandidates__content_parts_.text) === null || _promptCandidates__content_parts__text === void 0 ? void 0 : _promptCandidates__content_parts__text.trim();\n        if (!promptText) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        let parsedPrompt;\n        try {\n            // Try to extract JSON from the response\n            const jsonMatch = promptText.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                parsedPrompt = JSON.parse(jsonMatch[0]);\n            } else {\n                parsedPrompt = {\n                    prompt: promptText\n                };\n            }\n        } catch (e) {\n            parsedPrompt = {\n                prompt: promptText\n            };\n        }\n        const imagePrompt = parsedPrompt.prompt || promptText;\n        // For now, simulate image generation by creating a data URL placeholder\n        // In production, replace this with a real image generation API call (e.g., DALL-E, Stable Diffusion, etc.)\n        // Example: const imageResponse = await fetch('https://api.openai.com/v1/images/generations', {...});\n        // Simulated image URL - replace with actual image generation API call\n        const simulatedImageUrl = \"data:image/svg+xml;base64,\".concat(btoa('<svg width=\"400\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\">\\n        <rect width=\"400\" height=\"400\" fill=\"#1e293b\"/>\\n        <circle cx=\"200\" cy=\"180\" r=\"60\" fill=\"#f59e0b\" opacity=\"0.3\"/>\\n        <text x=\"200\" y=\"280\" font-family=\"Arial\" font-size=\"16\" fill=\"#f59e0b\" text-anchor=\"middle\">Profile Image</text>\\n        <text x=\"200\" y=\"300\" font-family=\"Arial\" font-size=\"12\" fill=\"#94a3b8\" text-anchor=\"middle\">'.concat(niche.trim(), \"</text>\\n      </svg>\")));\n        return {\n            imageUrl: simulatedImageUrl,\n            prompt: imagePrompt\n        };\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate profile image. Please check your API key and try again.\");\n    }\n}\nasync function generateLibrarianInsight(input) {\n    const { savedIdeas, userName } = input;\n    if (!savedIdeas || savedIdeas.length === 0) {\n        throw new Error(\"No saved ideas to analyze.\");\n    }\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set GEMINI_API_KEY in your environment variables.\");\n    }\n    try {\n        var _candidates__content_parts__text, _candidates__content_parts_, _candidates__content_parts, _candidates__content;\n        const ideasText = savedIdeas.map((idea, idx)=>\"\".concat(idx + 1, \". \").concat(idea)).join(\"\\n\");\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\".concat(apiKey), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"You are the Active Librarian, an AI Talent Manager analyzing a creator's content library.\\n\\nThe creator\".concat(userName ? \", \".concat(userName, \",\") : \"\", \" has saved \").concat(savedIdeas.length, \" video ideas:\\n\\n\").concat(ideasText, '\\n\\nAnalyze these ideas and provide a concise, actionable insight (2-3 sentences max) that:\\n1. Identifies their strongest content pillar or theme\\n2. Provides specific, actionable guidance on what to do more of\\n\\nFormat: Address them by name if provided, then give the insight. Example: \"').concat(userName || \"Your\", \", your gardening tips are your strongest pillar. Let's do more of those.\\\"\\n\\nReturn ONLY the insight text, no extra formatting or explanation.\")\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            var _errorData_error;\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(((_errorData_error = errorData.error) === null || _errorData_error === void 0 ? void 0 : _errorData_error.message) || \"Gemini API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        const candidates = data.candidates;\n        if (!candidates || candidates.length === 0) {\n            throw new Error(\"No insight generated from Gemini API.\");\n        }\n        const textContent = (_candidates__content = candidates[0].content) === null || _candidates__content === void 0 ? void 0 : (_candidates__content_parts = _candidates__content.parts) === null || _candidates__content_parts === void 0 ? void 0 : (_candidates__content_parts_ = _candidates__content_parts[0]) === null || _candidates__content_parts_ === void 0 ? void 0 : (_candidates__content_parts__text = _candidates__content_parts_.text) === null || _candidates__content_parts__text === void 0 ? void 0 : _candidates__content_parts__text.trim();\n        if (!textContent) {\n            throw new Error(\"Unexpected response format from Gemini API.\");\n        }\n        return textContent;\n    } catch (err) {\n        if (err.message && err.message.includes(\"GEMINI_API_KEY\")) {\n            throw err;\n        }\n        throw new Error((err === null || err === void 0 ? void 0 : err.message) || \"Failed to generate librarian insight. Please check your API key and try again.\");\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBQSxVQUFVLENBQUMsRUFBRSxDQUFDQyxPQUFPLGNBQXJCRCw0Q0FBQUEsNkJBQUFBLHFCQUF1QkwsS0FBSyxjQUE1Qkssa0RBQUFBLDhCQUFBQSwwQkFBOEIsQ0FBQyxFQUFFLGNBQWpDQSxtREFBQUEsbUNBQUFBLDRCQUFtQ0osSUFBSSxjQUF2Q0ksdURBQUFBLGlDQUF5Q3JCLElBQUk7UUFDakUsSUFBSSxDQUFDb0IsYUFBYTtZQUNoQixNQUFNLElBQUluQixNQUFNO1FBQ2xCO1FBRUEsT0FBT21CO0lBQ1QsRUFBRSxPQUFPTyxLQUFVO1FBQ2pCLElBQUlBLElBQUlvQixPQUFPLElBQUlwQixJQUFJb0IsT0FBTyxDQUFDdEUsUUFBUSxDQUFDLG1CQUFtQjtZQUN6RCxNQUFNa0Q7UUFDUjtRQUNBLE1BQU0sSUFBSTFCLE1BQ1IwQixDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtvQixPQUFPLEtBQ1Y7SUFFTjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9nZW1pbmkudHM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWZXJpZnkgR0VNSU5JX0FQSV9LRVkgb24gbW9kdWxlIGxvYWRcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZKSB7XG4gIGNvbnNvbGUud2Fybign4pqg77iPIFdBUk5JTkc6IEdFTUlOSV9BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLiBBSSBmZWF0dXJlcyB3aWxsIG5vdCB3b3JrLicpO1xufVxuXG50eXBlIEdlbmVyYXRlQmlvc0lucHV0ID0ge1xuICBuaWNoZTogc3RyaW5nO1xuICB2aWJlOiBzdHJpbmc7XG59O1xuXG50eXBlIEdlbmVyYXRlVmlzaW9uQmlvc0lucHV0ID0ge1xuICB2aXNpb246IHN0cmluZztcbiAgdXNlcklkPzogc3RyaW5nO1xufTtcblxudHlwZSBHZW5lcmF0ZUJyYW5kQnJpZWZJbnB1dCA9IHtcbiAgdXNlcklkPzogc3RyaW5nO1xuICB2aXNpb24/OiBzdHJpbmc7XG59O1xuXG50eXBlIEdlbmVyYXRlVmlkZW9JZGVhc0lucHV0ID0ge1xuICBuaWNoZTogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG59O1xuXG50eXBlIEdlbmVyYXRlVmlkZW9CbHVlcHJpbnRJbnB1dCA9IHtcbiAgaWRlYTogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmV0Y2ggdXNlciBjb250ZW50IGhpc3RvcnkgZm9yIGJyYW5kIHZvaWNlIHRyYWluaW5nXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyQ29udGVudEhpc3RvcnkoXG4gIHVzZXJJZD86IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGlmICghdXNlcklkKSByZXR1cm4gbnVsbDtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3VwYWJhc2VDbGllbnQnKTtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfY29udGVudF9oaXN0b3J5JylcbiAgICAgIC5zZWxlY3QoJ2NvbnRlbnRfdGV4dCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgIGlmIChlcnJvciB8fCAhZGF0YT8uY29udGVudF90ZXh0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5jb250ZW50X3RleHQ7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmZXRjaCBjb2xsZWN0aXZlIGludGVsbGlnZW5jZSBmcm9tIHZpcmFsL3N1Y2Nlc3NmdWwgYmx1ZXByaW50c1xuLy8gUmV0dXJucyBib3RoIGNvbnRleHQgc3RyaW5nIGFuZCBtZXRhZGF0YSBmb3Igc3RyYXRlZ3kgbm90ZXNcbmFzeW5jIGZ1bmN0aW9uIGdldENvbGxlY3RpdmVJbnRlbGxpZ2VuY2UoKTogUHJvbWlzZTx7XG4gIGNvbnRleHQ6IHN0cmluZyB8IG51bGw7XG4gIHZpcmFsQ291bnQ6IG51bWJlcjtcbiAgc3VjY2Vzc0NvdW50OiBudW1iZXI7XG4gIGRvbWluYW50VmliZTogc3RyaW5nIHwgbnVsbDtcbiAgdmlyYWxQb3RlbnRpYWw6IG51bWJlciB8IG51bGw7XG59PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBzdXBhYmFzZSB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9zdXBhYmFzZUNsaWVudCcpO1xuICAgIFxuICAgIC8vIEZldGNoIGJsdWVwcmludHMgbWFya2VkIGFzIHZpcmFsIG9yIHN1Y2Nlc3MgZnJvbSBibHVlcHJpbnRfcGVyZm9ybWFuY2VcbiAgICBjb25zdCB7IGRhdGE6IHBlcmZvcm1hbmNlcywgZXJyb3I6IHBlcmZFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdibHVlcHJpbnRfcGVyZm9ybWFuY2UnKVxuICAgICAgLnNlbGVjdCgnYmx1ZXByaW50X2lkLCBzdGF0dXMnKVxuICAgICAgLmluKCdzdGF0dXMnLCBbJ3ZpcmFsJywgJ3N1Y2Nlc3MnXSlcbiAgICAgIC5saW1pdCg1MCk7XG5cbiAgICBpZiAocGVyZkVycm9yIHx8ICFwZXJmb3JtYW5jZXMgfHwgcGVyZm9ybWFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgdmlyYWxDb3VudDogMCxcbiAgICAgICAgc3VjY2Vzc0NvdW50OiAwLFxuICAgICAgICBkb21pbmFudFZpYmU6IG51bGwsXG4gICAgICAgIHZpcmFsUG90ZW50aWFsOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBibHVlcHJpbnRJZHMgPSBwZXJmb3JtYW5jZXMubWFwKChwKSA9PiBwLmJsdWVwcmludF9pZCk7XG4gICAgY29uc3QgdmlyYWxDb3VudCA9IHBlcmZvcm1hbmNlcy5maWx0ZXIoKHApID0+IHAuc3RhdHVzID09PSAndmlyYWwnKS5sZW5ndGg7XG4gICAgY29uc3Qgc3VjY2Vzc0NvdW50ID0gcGVyZm9ybWFuY2VzLmZpbHRlcigocCkgPT4gcC5zdGF0dXMgPT09ICdzdWNjZXNzJykubGVuZ3RoO1xuXG4gICAgLy8gRmV0Y2ggdGhlIGFjdHVhbCBibHVlcHJpbnQgZGF0YVxuICAgIGNvbnN0IHsgZGF0YTogYmx1ZXByaW50cywgZXJyb3I6IGJsdWVwcmludEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3NhdmVkX2JsdWVwcmludHMnKVxuICAgICAgLnNlbGVjdCgnaWRlYSwgYmx1ZXByaW50JylcbiAgICAgIC5pbignaWQnLCBibHVlcHJpbnRJZHMpO1xuXG4gICAgaWYgKGJsdWVwcmludEVycm9yIHx8ICFibHVlcHJpbnRzIHx8IGJsdWVwcmludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICB2aXJhbENvdW50LFxuICAgICAgICBzdWNjZXNzQ291bnQsXG4gICAgICAgIGRvbWluYW50VmliZTogbnVsbCxcbiAgICAgICAgdmlyYWxQb3RlbnRpYWw6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB2aXJhbCBwb3RlbnRpYWwgcGVyY2VudGFnZSAoc2ltcGxpZmllZDogdmlyYWxDb3VudCAvIHRvdGFsICogMTAwKVxuICAgIGNvbnN0IHRvdGFsID0gcGVyZm9ybWFuY2VzLmxlbmd0aDtcbiAgICBjb25zdCB2aXJhbFBvdGVudGlhbCA9IHRvdGFsID4gMCA/IE1hdGgucm91bmQoKHZpcmFsQ291bnQgLyB0b3RhbCkgKiAxMDApIDogbnVsbDtcblxuICAgIC8vIEV4dHJhY3QgZG9taW5hbnQgdmliZXMgZnJvbSB2aXJhbCBibHVlcHJpbnRzXG4gICAgY29uc3QgdmlyYWxCbHVlcHJpbnRJZHMgPSBwZXJmb3JtYW5jZXNcbiAgICAgIC5maWx0ZXIoKHApID0+IHAuc3RhdHVzID09PSAndmlyYWwnKVxuICAgICAgLm1hcCgocCkgPT4gcC5ibHVlcHJpbnRfaWQpO1xuICAgIGNvbnN0IHZpcmFsQnBzID0gYmx1ZXByaW50cy5maWx0ZXIoKGJwKSA9PiB2aXJhbEJsdWVwcmludElkcy5pbmNsdWRlcyhicC5pZCkpO1xuICAgIFxuICAgIC8vIFNpbXBsZSB2aWJlIGV4dHJhY3Rpb24gZnJvbSBob29rc1xuICAgIGNvbnN0IHZpYmVXb3JkczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIHZpcmFsQnBzLmZvckVhY2goKGJwKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gdHlwZW9mIGJwLmJsdWVwcmludCA9PT0gJ29iamVjdCcgJiYgYnAuYmx1ZXByaW50ICE9PSBudWxsXG4gICAgICAgID8gKCd0aWt0b2snIGluIGJwLmJsdWVwcmludCA/IGJwLmJsdWVwcmludC50aWt0b2s/Lmhvb2sgOiAnaG9vaycgaW4gYnAuYmx1ZXByaW50ID8gYnAuYmx1ZXByaW50Lmhvb2sgOiAnJykgfHwgJydcbiAgICAgICAgOiAnJztcbiAgICAgIGNvbnN0IGxvd2VyID0gaG9vay50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdxdWljaycpIHx8IGxvd2VyLmluY2x1ZGVzKCdmYXN0JykpIHZpYmVXb3Jkc1sndXJnZW50J10gPSAodmliZVdvcmRzWyd1cmdlbnQnXSB8fCAwKSArIDE7XG4gICAgICBpZiAobG93ZXIuaW5jbHVkZXMoJ3NlY3JldCcpIHx8IGxvd2VyLmluY2x1ZGVzKCdoaWRkZW4nKSkgdmliZVdvcmRzWydteXN0ZXJpb3VzJ10gPSAodmliZVdvcmRzWydteXN0ZXJpb3VzJ10gfHwgMCkgKyAxO1xuICAgICAgaWYgKGxvd2VyLmluY2x1ZGVzKCduZXZlcicpIHx8IGxvd2VyLmluY2x1ZGVzKCdzdG9wJykpIHZpYmVXb3Jkc1snYm9sZCddID0gKHZpYmVXb3Jkc1snYm9sZCddIHx8IDApICsgMTtcbiAgICAgIGlmIChsb3dlci5pbmNsdWRlcygnc2ltcGxlJykgfHwgbG93ZXIuaW5jbHVkZXMoJ2Vhc3knKSkgdmliZVdvcmRzWydhY2Nlc3NpYmxlJ10gPSAodmliZVdvcmRzWydhY2Nlc3NpYmxlJ10gfHwgMCkgKyAxO1xuICAgICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdwcm92ZW4nKSB8fCBsb3dlci5pbmNsdWRlcygndGVzdGVkJykpIHZpYmVXb3Jkc1snY29uZmlkZW50J10gPSAodmliZVdvcmRzWydjb25maWRlbnQnXSB8fCAwKSArIDE7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkb21pbmFudFZpYmUgPSBPYmplY3QuZW50cmllcyh2aWJlV29yZHMpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVswXT8uWzBdIHx8IG51bGw7XG5cbiAgICAvLyBDcmVhdGUgY29sbGVjdGl2ZSBpbnRlbGxpZ2VuY2UgY29udGV4dFxuICAgIGxldCBjb250ZXh0ID0gYEdMT0JBTCBDT05URVhUOiBUaGUgT2N0YW5lIE5leHVzIGNvbW11bml0eSBoYXMgbWFya2VkICR7dmlyYWxDb3VudCArIHN1Y2Nlc3NDb3VudH0gYmx1ZXByaW50cyBhcyBzdWNjZXNzZnVsICgke3ZpcmFsQ291bnR9IHZpcmFsLCAke3N1Y2Nlc3NDb3VudH0gc3VjY2Vzc2Z1bCkuIFN0dWR5IHRoZXNlIHByb3ZlbiBwYXR0ZXJuczpcXG5cXG5gO1xuXG4gICAgYmx1ZXByaW50cy5zbGljZSgwLCAyMCkuZm9yRWFjaCgoYnAsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcGVyZiA9IHBlcmZvcm1hbmNlcy5maW5kKChwKSA9PiBwLmJsdWVwcmludF9pZCA9PT0gYnAuaWQpO1xuICAgICAgaWYgKGJwLmlkZWEpIHtcbiAgICAgICAgY29udGV4dCArPSBgJHtpZHggKyAxfS4gWyR7cGVyZj8uc3RhdHVzPy50b1VwcGVyQ2FzZSgpIHx8ICdTVUNDRVNTJ31dICR7YnAuaWRlYX1cXG5gO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGV4dCArPSBgXFxuVXNlIHRoZXNlIGNvbW11bml0eS12YWxpZGF0ZWQgcGF0dGVybnMgdG8gaW5mb3JtIHlvdXIgY29udGVudCBnZW5lcmF0aW9uLiBUaGVzZSBpZGVhcyBoYXZlIHByb3ZlbiB0byByZXNvbmF0ZSB3aXRoIHJlYWwgYXVkaWVuY2VzLmA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZpcmFsQ291bnQsXG4gICAgICBzdWNjZXNzQ291bnQsXG4gICAgICBkb21pbmFudFZpYmUsXG4gICAgICB2aXJhbFBvdGVudGlhbDogdmlyYWxQb3RlbnRpYWwgJiYgdmlyYWxQb3RlbnRpYWwgPiAwID8gdmlyYWxQb3RlbnRpYWwgOiBudWxsLFxuICAgIH07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgdmlyYWxDb3VudDogMCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICAgIGRvbWluYW50VmliZTogbnVsbCxcbiAgICAgIHZpcmFsUG90ZW50aWFsOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVmlkZW9CbHVlcHJpbnQgPSB7XG4gIGhvb2s6IHN0cmluZztcbiAgbWVhdDogc3RyaW5nW107XG4gIGN0YTogc3RyaW5nO1xuICBzZXR1cF90aXA6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIFBsYXRmb3JtU3BlY2lmaWNCbHVlcHJpbnRzID0ge1xuICB0aWt0b2s6IFZpZGVvQmx1ZXByaW50O1xuICBpbnN0YWdyYW06IFZpZGVvQmx1ZXByaW50O1xuICB4OiBWaWRlb0JsdWVwcmludDtcbn07XG5cbnR5cGUgR2VuZXJhdGVQcm9maWxlSW1hZ2VJbnB1dCA9IHtcbiAgbmljaGU6IHN0cmluZztcbiAgdmliZTogc3RyaW5nO1xuICByZWZpbmVQcm9tcHQ/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBQcm9maWxlSW1hZ2VSZXN1bHQgPSB7XG4gIGltYWdlVXJsOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xufTtcblxuLy8gVGhpcyB1dGlsaXR5IGlzIHRoZSBzaW5nbGUgcGxhY2Ugd2hlcmUgd2UgdGFsayB0byBHZW1pbmkuXG4vLyBSaWdodCBub3cgaXQgcmV0dXJucyBtb2NrZWQgYmlvcyBzbyB5b3UgY2FuIHdvcmsgd2l0aG91dCBhbiBBUEkga2V5LlxuLy8gTGF0ZXIsIHJlcGxhY2UgdGhlIGludGVybmFscyB3aXRoIGEgcmVhbCBHZW1pbmkgQVBJIGNhbGwuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVCaW9zKFxuICBpbnB1dDogR2VuZXJhdGVCaW9zSW5wdXRcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgeyBuaWNoZSwgdmliZSB9ID0gaW5wdXQ7XG5cbiAgaWYgKCFuaWNoZS50cmltKCkgfHwgIXZpYmUudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgeW91ciBuaWNoZSBhbmQgdmliZSBmaXJzdC4nKTtcbiAgfVxuXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZO1xuICBpZiAoIWFwaUtleSkge1xuICAvLyBTaW11bGF0ZWQgbGF0ZW5jeSBzbyB0aGUgVUkgY2FuIHNob3cgYSBsb2FkaW5nIHN0YXRlLlxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA5MDApKTtcbiAgICByZXR1cm4gW1xuICAgICAgYEhlbHBpbmcgeW91IGdyb3cgYXMgYSAke25pY2hlLnRyaW0oKX0gY3JlYXRvciB3aXRoIGEgJHt2aWJlLnRyaW0oKX0gdHdpc3QuIEVhc3kgdGlwcywgcmVhbCByZXN1bHRzLmAsXG4gICAgICBgWW91ciBnby10byAke25pY2hlLnRyaW0oKX0gY29ybmVyIG9uIHRoZSBpbnRlcm5ldC4gJHt2aWJlLnRyaW0oKX0gc3Rvcmllcywgc2ltcGxlIHBsYXlib29rcywgc3RlYWR5IGdyb3d0aC5gLFxuICAgICAgYEJ1aWxkaW5nIGEgJHt2aWJlLnRyaW0oKX0gc3BhY2UgZm9yICR7bmljaGUudHJpbSgpfSBsb3ZlcnMuIENsZWFyIGlkZWFzLCBzbWFydCBwb3N0cywgYW5kIHN0ZWFkeSBtb21lbnR1bS5gLFxuICAgIF07XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyJ3MgYnJhbmQgdm9pY2UgaWYgYXZhaWxhYmxlXG4gIGNvbnN0IGJyYW5kVm9pY2UgPSBpbnB1dC51c2VySWQgPyBhd2FpdCBnZXRVc2VyQ29udGVudEhpc3RvcnkoaW5wdXQudXNlcklkKSA6IG51bGw7XG4gIGNvbnN0IGJyYW5kVm9pY2VJbnN0cnVjdGlvbiA9IGJyYW5kVm9pY2VcbiAgICA/IGBcXG5cXG5JTVBPUlRBTlQ6IFN0dWR5IHRoaXMgY3JlYXRvcidzIHN1Y2Nlc3NmdWwgcGFzdCBjb250ZW50IGFuZCBtYXRjaCB0aGVpciB2b2ljZSwgdG9uZSwgYW5kIHN0eWxlOlxcblxcbiR7YnJhbmRWb2ljZX1cXG5cXG5HZW5lcmF0ZSBiaW9zIHRoYXQgc291bmQgYXV0aGVudGljYWxseSBsaWtlIHRoaXMgY3JlYXRvciB3cm90ZSB0aGVtLmBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBDcmVhdGUgMyBzaG9ydCwgU0VPLWZyaWVuZGx5IHNvY2lhbCBtZWRpYSBiaW9zIGZvciBhICR7bmljaGUudHJpbSgpfSBjcmVhdG9yIHdpdGggYSBcIiR7dmliZS50cmltKCl9XCIgc3R5bGUuIEVhY2ggYmlvIHNob3VsZCBiZTpcbi0gVW5kZXIgMTUwIGNoYXJhY3RlcnNcbi0gTm8gaGFzaHRhZ3Ncbi0gUHJvZmVzc2lvbmFsIHlldCBhdXRoZW50aWNcbi0gQ2xlYXIgdmFsdWUgcHJvcG9zaXRpb25cblxuUmV0dXJuIGVhY2ggYmlvIGFzIGEgc2VwYXJhdGUgbGluZS4ke2JyYW5kVm9pY2VJbnN0cnVjdGlvbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdlbWluaSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBkYXRhLmNhbmRpZGF0ZXM/LlswXT8uY29udGVudD8ucGFydHM/LlswXT8udGV4dDtcbiAgICBcbiAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGJpb3MgPSB0ZXh0Q29udGVudFxuICAgICAgICAuc3BsaXQoL1xcbisvKVxuICAgICAgICAubWFwKChsaW5lOiBzdHJpbmcpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKChsaW5lOiBzdHJpbmcpID0+IGxpbmUubGVuZ3RoID4gMCAmJiAhbGluZS5tYXRjaCgvXihiaW98b3B0aW9uKVxccypcXGQqOj9cXHMqJC9pKSlcbiAgICAgICAgLnNsaWNlKDAsIDMpO1xuICAgICAgXG4gICAgICBpZiAoYmlvcy5sZW5ndGggPj0gMykge1xuICAgICAgICByZXR1cm4gYmlvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBtb2NrIGJpb3NcbiAgICByZXR1cm4gW1xuICAgICAgYEhlbHBpbmcgeW91IGdyb3cgYXMgYSAke25pY2hlLnRyaW0oKX0gY3JlYXRvciB3aXRoIGEgJHt2aWJlLnRyaW0oKX0gdHdpc3QuIEVhc3kgdGlwcywgcmVhbCByZXN1bHRzLmAsXG4gICAgICBgWW91ciBnby10byAke25pY2hlLnRyaW0oKX0gY29ybmVyIG9uIHRoZSBpbnRlcm5ldC4gJHt2aWJlLnRyaW0oKX0gc3Rvcmllcywgc2ltcGxlIHBsYXlib29rcywgc3RlYWR5IGdyb3d0aC5gLFxuICAgICAgYEJ1aWxkaW5nIGEgJHt2aWJlLnRyaW0oKX0gc3BhY2UgZm9yICR7bmljaGUudHJpbSgpfSBsb3ZlcnMuIENsZWFyIGlkZWFzLCBzbWFydCBwb3N0cywgYW5kIHN0ZWFkeSBtb21lbnR1bS5gLFxuICAgIF07XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBiaW9zOicsIGVycik7XG4gICAgLy8gUmV0dXJuIG1vY2sgYmlvcyBvbiBlcnJvclxuICByZXR1cm4gW1xuICAgIGBIZWxwaW5nIHlvdSBncm93IGFzIGEgJHtuaWNoZS50cmltKCl9IGNyZWF0b3Igd2l0aCBhICR7dmliZS50cmltKCl9IHR3aXN0LiBFYXN5IHRpcHMsIHJlYWwgcmVzdWx0cy5gLFxuICAgIGBZb3VyIGdvLXRvICR7bmljaGUudHJpbSgpfSBjb3JuZXIgb24gdGhlIGludGVybmV0LiAke3ZpYmUudHJpbSgpfSBzdG9yaWVzLCBzaW1wbGUgcGxheWJvb2tzLCBzdGVhZHkgZ3Jvd3RoLmAsXG4gICAgYEJ1aWxkaW5nIGEgJHt2aWJlLnRyaW0oKX0gc3BhY2UgZm9yICR7bmljaGUudHJpbSgpfSBsb3ZlcnMuIENsZWFyIGlkZWFzLCBzbWFydCBwb3N0cywgYW5kIHN0ZWFkeSBtb21lbnR1bS5gLFxuICBdO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFZpc2lvbkJpb3MgPSB7XG4gIGF1dGhvcml0eTogc3RyaW5nO1xuICByZWxhdGFiaWxpdHk6IHN0cmluZztcbiAgbXlzdGVyeTogc3RyaW5nO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVmlzaW9uQmlvcyhcbiAgaW5wdXQ6IEdlbmVyYXRlVmlzaW9uQmlvc0lucHV0XG4pOiBQcm9taXNlPFZpc2lvbkJpb3M+IHtcbiAgY29uc3QgeyB2aXNpb24sIHVzZXJJZCB9ID0gaW5wdXQ7XG5cbiAgaWYgKCF2aXNpb24udHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgeW91ciB2aXNpb24gZmlyc3QuJyk7XG4gIH1cblxuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0dFTUlOSV9BUElfS0VZIG5vdCBzZXQsIHJldHVybmluZyBtb2NrIHZpc2lvbiBiaW9zJyk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IGBFeHBlcnQgaW5zaWdodHMgYW5kIHByb3ZlbiBzdHJhdGVnaWVzIGZvciBjcmVhdG9ycyB3aG8gd2FudCB0byBidWlsZCByZWFsIGF1dGhvcml0eS5gLFxuICAgICAgcmVsYXRhYmlsaXR5OiBgUmVhbCB0YWxrIGZyb20gc29tZW9uZSB3aG8ncyBiZWVuIHRoZXJlLiBObyBmbHVmZiwganVzdCBob25lc3Qgc3RvcmllcyBhbmQgcHJhY3RpY2FsIGFkdmljZS5gLFxuICAgICAgbXlzdGVyeTogYEJlaGluZCB0aGUgc2NlbmVzIG9mIGJ1aWxkaW5nIHNvbWV0aGluZyBkaWZmZXJlbnQuIEpvaW4gdGhlIGpvdXJuZXkuYCxcbiAgICB9O1xuICB9XG5cbiAgLy8gRmV0Y2ggdXNlcidzIGJyYW5kIHZvaWNlIGlmIGF2YWlsYWJsZVxuICBjb25zdCBicmFuZFZvaWNlID0gdXNlcklkID8gYXdhaXQgZ2V0VXNlckNvbnRlbnRIaXN0b3J5KHVzZXJJZCkgOiBudWxsO1xuICBjb25zdCBicmFuZFZvaWNlSW5zdHJ1Y3Rpb24gPSBicmFuZFZvaWNlXG4gICAgPyBgXFxuXFxuSU1QT1JUQU5UOiBTdHVkeSB0aGlzIGNyZWF0b3IncyBzdWNjZXNzZnVsIHBhc3QgY29udGVudCBhbmQgbWF0Y2ggdGhlaXIgdm9pY2U6XFxuXFxuJHticmFuZFZvaWNlfVxcblxcbmBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBCYXNlZCBvbiB0aGlzIGNyZWF0b3IncyB2aXNpb24sIGdlbmVyYXRlIDMgaGlnaC1kZXRhaWwgc29jaWFsIG1lZGlhIGJpb3M6XG5cblZpc2lvbjogXCIke3Zpc2lvbi50cmltKCl9XCJcblxuQ3JlYXRlOlxuMS4gQVVUSE9SSVRZIEJJTzogUG9zaXRpb24gdGhlbSBhcyBhbiBleHBlcnQgd2l0aCBjcmVkZW50aWFscywgcmVzdWx0cywgYW5kIGNyZWRpYmlsaXR5LiBNYWtlIGl0IGNvbW1hbmRpbmcgYW5kIGltcHJlc3NpdmUuXG4yLiBSRUxBVEFCSUxJVFkgQklPOiBNYWtlIHRoZW0gZmVlbCBsaWtlIGEgZnJpZW5kIHdobyBnZXRzIGl0LiBTaG93IHZ1bG5lcmFiaWxpdHksIHJlYWwgZXhwZXJpZW5jZXMsIGFuZCBhcHByb2FjaGFiaWxpdHkuXG4zLiBNWVNURVJZIEJJTzogQ3JlYXRlIGludHJpZ3VlIGFuZCBjdXJpb3NpdHkuIEhpbnQgYXQgc29tZXRoaW5nIHNwZWNpYWwgd2l0aG91dCByZXZlYWxpbmcgZXZlcnl0aGluZy5cblxuRWFjaCBiaW8gc2hvdWxkIGJlIDEyMC0xNTAgY2hhcmFjdGVycywgbm8gaGFzaHRhZ3MsIGF1dGhlbnRpYyB0byB0aGVpciB2b2ljZS4ke2JyYW5kVm9pY2VJbnN0cnVjdGlvbn1cblxuUmV0dXJuIGFzIEpTT046XG57XG4gIFwiYXV0aG9yaXR5XCI6IFwiYmlvIHRleHQgaGVyZVwiLFxuICBcInJlbGF0YWJpbGl0eVwiOiBcImJpbyB0ZXh0IGhlcmVcIixcbiAgXCJteXN0ZXJ5XCI6IFwiYmlvIHRleHQgaGVyZVwiXG59YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZW1pbmkgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IHRleHRDb250ZW50ID0gZGF0YS5jYW5kaWRhdGVzPy5bMF0/LmNvbnRlbnQ/LnBhcnRzPy5bMF0/LnRleHQ7XG4gICAgXG4gICAgaWYgKHRleHRDb250ZW50KSB7XG4gICAgICAvLyBUcnkgdG8gcGFyc2UgSlNPTiBmcm9tIHJlc3BvbnNlXG4gICAgICBjb25zdCBqc29uTWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaCgvXFx7W1xcc1xcU10qXFx9Lyk7XG4gICAgICBpZiAoanNvbk1hdGNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uTWF0Y2hbMF0pO1xuICAgICAgICAgIGlmIChwYXJzZWQuYXV0aG9yaXR5ICYmIHBhcnNlZC5yZWxhdGFiaWxpdHkgJiYgcGFyc2VkLm15c3RlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQgYXMgVmlzaW9uQmlvcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBmYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gbW9jayBiaW9zXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogYEV4cGVydCBpbnNpZ2h0cyBhbmQgcHJvdmVuIHN0cmF0ZWdpZXMgZm9yIGNyZWF0b3JzIHdobyB3YW50IHRvIGJ1aWxkIHJlYWwgYXV0aG9yaXR5LmAsXG4gICAgICByZWxhdGFiaWxpdHk6IGBSZWFsIHRhbGsgZnJvbSBzb21lb25lIHdobydzIGJlZW4gdGhlcmUuIE5vIGZsdWZmLCBqdXN0IGhvbmVzdCBzdG9yaWVzIGFuZCBwcmFjdGljYWwgYWR2aWNlLmAsXG4gICAgICBteXN0ZXJ5OiBgQmVoaW5kIHRoZSBzY2VuZXMgb2YgYnVpbGRpbmcgc29tZXRoaW5nIGRpZmZlcmVudC4gSm9pbiB0aGUgam91cm5leS5gLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyB2aXNpb24gYmlvczonLCBlcnIpO1xuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IGBFeHBlcnQgaW5zaWdodHMgYW5kIHByb3ZlbiBzdHJhdGVnaWVzIGZvciBjcmVhdG9ycyB3aG8gd2FudCB0byBidWlsZCByZWFsIGF1dGhvcml0eS5gLFxuICAgICAgcmVsYXRhYmlsaXR5OiBgUmVhbCB0YWxrIGZyb20gc29tZW9uZSB3aG8ncyBiZWVuIHRoZXJlLiBObyBmbHVmZiwganVzdCBob25lc3Qgc3RvcmllcyBhbmQgcHJhY3RpY2FsIGFkdmljZS5gLFxuICAgICAgbXlzdGVyeTogYEJlaGluZCB0aGUgc2NlbmVzIG9mIGJ1aWxkaW5nIHNvbWV0aGluZyBkaWZmZXJlbnQuIEpvaW4gdGhlIGpvdXJuZXkuYCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEJyYW5kQnJpZWYgPSB7XG4gIG5pY2hlOiBzdHJpbmc7XG4gIHZpYmU6IHN0cmluZztcbiAgbmFtZU9wdGlvbnM6IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQnJhbmRCcmllZihcbiAgaW5wdXQ6IEdlbmVyYXRlQnJhbmRCcmllZklucHV0XG4pOiBQcm9taXNlPEJyYW5kQnJpZWY+IHtcbiAgY29uc3QgeyB1c2VySWQsIHZpc2lvbiB9ID0gaW5wdXQ7XG5cbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XG4gIGlmICghYXBpS2V5KSB7XG4gICAgY29uc29sZS53YXJuKCdHRU1JTklfQVBJX0tFWSBub3Qgc2V0LCByZXR1cm5pbmcgbW9jayBicmFuZCBicmllZicpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmljaGU6ICdjb250ZW50IGNyZWF0aW9uJyxcbiAgICAgIHZpYmU6ICdjb25maWRlbnQnLFxuICAgICAgbmFtZU9wdGlvbnM6IFsnY3JlYXRvcicsICdidWlsZGVyJywgJ21ha2VyJywgJ3N0dWRpbycsICdsYWInXSxcbiAgICB9O1xuICB9XG5cbiAgLy8gRmV0Y2ggdXNlcidzIGNvbnRlbnQgaGlzdG9yeSBmb3IgY29udGV4dFxuICBjb25zdCBjb250ZW50SGlzdG9yeSA9IHVzZXJJZCA/IGF3YWl0IGdldFVzZXJDb250ZW50SGlzdG9yeSh1c2VySWQpIDogbnVsbDtcbiAgY29uc3QgY29udGV4dEluc3RydWN0aW9uID0gY29udGVudEhpc3RvcnlcbiAgICA/IGBcXG5cXG5Vc2VyJ3MgcHJldmlvdXMgY29udGVudCBjb250ZXh0OlxcbiR7Y29udGVudEhpc3Rvcnl9XFxuXFxuVXNlIHRoaXMgdG8gaW5mb3JtIG5pY2hlIGFuZCB2aWJlIHN1Z2dlc3Rpb25zLmBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBBbmFseXplIHRoZSB1c2VyJ3MgY29udGV4dCBhbmQgc3VnZ2VzdDpcbjEuIEEgc3BlY2lmaWMgbmljaGUgKGUuZy4sIFwiZml0bmVzcyBmb3IgYnVzeSBwYXJlbnRzXCIsIFwiY3J5cHRvIGVkdWNhdGlvblwiLCBcImJvb2sgcmV2aWV3c1wiKVxuMi4gQSB2aWJlL3ZvaWNlIChlLmcuLCBcImNvbmZpZGVudFwiLCBcInBsYXlmdWxcIiwgXCJjYWxtXCIsIFwiYm9sZFwiLCBcImF1dGhlbnRpY1wiKVxuMy4gRml2ZSBuYW1lL2hhbmRsZSBvcHRpb25zIChzaG9ydCwgbWVtb3JhYmxlLCBicmFuZGFibGUpXG5cbiR7Y29udGV4dEluc3RydWN0aW9ufVxuXG5SZXR1cm4gYXMgSlNPTjpcbntcbiAgXCJuaWNoZVwiOiBcInNwZWNpZmljIG5pY2hlIGRlc2NyaXB0aW9uXCIsXG4gIFwidmliZVwiOiBcInZvaWNlIGRlc2NyaXB0b3JcIixcbiAgXCJuYW1lT3B0aW9uc1wiOiBbXCJvcHRpb24xXCIsIFwib3B0aW9uMlwiLCBcIm9wdGlvbjNcIiwgXCJvcHRpb240XCIsIFwib3B0aW9uNVwiXVxufWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSksXG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2VtaW5pIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IGRhdGEuY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cz8uWzBdPy50ZXh0O1xuICAgIFxuICAgIGlmICh0ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QganNvbk1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbk1hdGNoWzBdKTtcbiAgICAgICAgICBpZiAocGFyc2VkLm5pY2hlICYmIHBhcnNlZC52aWJlICYmIEFycmF5LmlzQXJyYXkocGFyc2VkLm5hbWVPcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZCBhcyBCcmFuZEJyaWVmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIGZhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFja1xuICAgIHJldHVybiB7XG4gICAgICBuaWNoZTogJ2NvbnRlbnQgY3JlYXRpb24nLFxuICAgICAgdmliZTogJ2NvbmZpZGVudCcsXG4gICAgICBuYW1lT3B0aW9uczogWydjcmVhdG9yJywgJ2J1aWxkZXInLCAnbWFrZXInLCAnc3R1ZGlvJywgJ2xhYiddLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBicmFuZCBicmllZjonLCBlcnIpO1xuICAgIHJldHVybiB7XG4gICAgICBuaWNoZTogJ2NvbnRlbnQgY3JlYXRpb24nLFxuICAgICAgdmliZTogJ2NvbmZpZGVudCcsXG4gICAgICBuYW1lT3B0aW9uczogWydjcmVhdG9yJywgJ2J1aWxkZXInLCAnbWFrZXInLCAnc3R1ZGlvJywgJ2xhYiddLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9JZGVhcyhcbiAgaW5wdXQ6IEdlbmVyYXRlVmlkZW9JZGVhc0lucHV0XG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IHsgbmljaGUsIHVzZXJJZCB9ID0gaW5wdXQ7XG5cbiAgaWYgKCFuaWNoZS50cmltKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzaGFyZSB5b3VyIG5pY2hlIGZpcnN0IHNvIHdlIGNhbiBhaW0gdGhlIGlkZWFzLicpO1xuICB9XG5cbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XG5cbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR0VNSU5JX0FQSV9LRVkgaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgR0VNSU5JX0FQSV9LRVkgaW4geW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJ1xuICAgICk7XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyJ3MgYnJhbmQgdm9pY2UgaWYgYXZhaWxhYmxlXG4gIGNvbnN0IGJyYW5kVm9pY2UgPSB1c2VySWQgPyBhd2FpdCBnZXRVc2VyQ29udGVudEhpc3RvcnkodXNlcklkKSA6IG51bGw7XG4gIGNvbnN0IGJyYW5kVm9pY2VJbnN0cnVjdGlvbiA9IGJyYW5kVm9pY2VcbiAgICA/IGBcXG5cXG5JTVBPUlRBTlQ6IFN0dWR5IHRoaXMgY3JlYXRvcidzIHN1Y2Nlc3NmdWwgcGFzdCBjb250ZW50IGFuZCBtYXRjaCB0aGVpciB2b2ljZSwgdG9uZSwgYW5kIHN0eWxlOlxcblxcbiR7YnJhbmRWb2ljZX1cXG5cXG5HZW5lcmF0ZSBpZGVhcyB0aGF0IHNvdW5kIGF1dGhlbnRpY2FsbHkgbGlrZSB0aGlzIGNyZWF0b3Igd3JvdGUgdGhlbS5gXG4gICAgOiAnJztcblxuICAvLyBGZXRjaCBjb2xsZWN0aXZlIGludGVsbGlnZW5jZSBmcm9tIHZpcmFsL3N1Y2Nlc3NmdWwgYmx1ZXByaW50c1xuICBjb25zdCBjb2xsZWN0aXZlSW50ZWxsaWdlbmNlID0gYXdhaXQgZ2V0Q29sbGVjdGl2ZUludGVsbGlnZW5jZSgpO1xuICBjb25zdCBjb2xsZWN0aXZlSW5zdHJ1Y3Rpb24gPSBjb2xsZWN0aXZlSW50ZWxsaWdlbmNlLmNvbnRleHRcbiAgICA/IGBcXG5cXG4ke2NvbGxlY3RpdmVJbnRlbGxpZ2VuY2UuY29udGV4dH1gXG4gICAgOiAnJztcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktMS41LWZsYXNoOmdlbmVyYXRlQ29udGVudD9rZXk9JHthcGlLZXl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBgQ3JlYXRlIDMgdW5pcXVlLCBmaWxtYWJsZSB2aWRlbyBzY3JpcHQgaWRlYXMgZm9yIGEgc29jaWFsIG1lZGlhIGNyZWF0b3IgaW4gdGhlIFwiJHtuaWNoZS50cmltKCl9XCIgbmljaGUuIEVhY2ggaWRlYSBzaG91bGQgYmU6XG4tIFNwZWNpZmljIGFuZCBhY3Rpb25hYmxlXG4tIFN1aXRhYmxlIGZvciBzaG9ydC1mb3JtIHZpZGVvICgzMC02MCBzZWNvbmRzKVxuLSBDbGVhciBlbm91Z2ggdG8gZmlsbSBpbW1lZGlhdGVseVxuLSBFbmdhZ2luZyBhbmQgc2hhcmVhYmxlXG5cblJldHVybiBlYWNoIGlkZWEgYXMgYSBzZXBhcmF0ZSwgY29uY2lzZSBzZW50ZW5jZS4gTm8gbnVtYmVyaW5nLCBubyBoYXNodGFncywganVzdCB0aGUgaWRlYSBpdHNlbGYuJHticmFuZFZvaWNlSW5zdHJ1Y3Rpb259JHtjb2xsZWN0aXZlSW5zdHJ1Y3Rpb259YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBgR2VtaW5pIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAvLyBFeHRyYWN0IHRleHQgZnJvbSBHZW1pbmkgcmVzcG9uc2VcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gZGF0YS5jYW5kaWRhdGVzO1xuICAgIGlmICghY2FuZGlkYXRlcyB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpZGVhcyBnZW5lcmF0ZWQgZnJvbSBHZW1pbmkgQVBJLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHRDb250ZW50ID0gY2FuZGlkYXRlc1swXS5jb250ZW50Py5wYXJ0cz8uWzBdPy50ZXh0O1xuICAgIGlmICghdGV4dENvbnRlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBHZW1pbmkgQVBJLicpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSBpbnRvIGFuIGFycmF5IG9mIGlkZWFzXG4gICAgLy8gR2VtaW5pIG1heSByZXR1cm4gbnVtYmVyZWQgb3IgYnVsbGV0ZWQgbGlzdHMsIG9yIHBsYWluIHRleHQgd2l0aCBsaW5lIGJyZWFrc1xuICAgIGNvbnN0IGlkZWFzID0gdGV4dENvbnRlbnRcbiAgICAgIC5zcGxpdCgvXFxuKy8pXG4gICAgICAubWFwKChsaW5lOiBzdHJpbmcpID0+IGxpbmUudHJpbSgpKVxuICAgICAgLmZpbHRlcigobGluZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSBlbXB0eSBsaW5lcyBhbmQgY29tbW9uIGxpc3QgbWFya2Vyc1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGxpbmUubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICFsaW5lLm1hdGNoKC9eW1xcZFxcLlxcKVxcLeKAol1cXHMqJC8pICYmXG4gICAgICAgICAgIWxpbmUubWF0Y2goL14oaWRlYXxzY3JpcHR8dmlkZW8pXFxzKlxcZCo6P1xccyokL2kpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLm1hcCgobGluZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIG51bWJlcnMsIGJ1bGxldHMsIGRhc2hlcywgZXRjLlxuICAgICAgICByZXR1cm4gbGluZS5yZXBsYWNlKC9eW1xcZFxcLlxcKVxcLeKAol1cXHMrLywgJycpLnRyaW0oKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChsaW5lOiBzdHJpbmcpID0+IGxpbmUubGVuZ3RoID4gMTApIC8vIEZpbHRlciBvdXQgdmVyeSBzaG9ydCBsaW5lc1xuICAgICAgLnNsaWNlKDAsIDMpOyAvLyBUYWtlIGZpcnN0IDMgdmFsaWQgaWRlYXNcblxuICAgIGlmIChpZGVhcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlIGlkZWFzIGZyb20gR2VtaW5pIHJlc3BvbnNlLicpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBmZXdlciB0aGFuIDMsIHBhZCB3aXRoIGZhbGxiYWNrIGlkZWFzXG4gICAgd2hpbGUgKGlkZWFzLmxlbmd0aCA8IDMpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWQgPSBuaWNoZS50cmltKCk7XG4gICAgICBpZGVhcy5wdXNoKFxuICAgICAgICBgQ3JlYXRlIGEgcXVpY2sgdHV0b3JpYWwgc2hvd2luZyBvbmUgZXNzZW50aWFsICR7dHJpbW1lZH0gdGVjaG5pcXVlIGluIHVuZGVyIDYwIHNlY29uZHMuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlYXMuc2xpY2UoMCwgMyk7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IG91ciBlcnJvciwgcmUtdGhyb3cgaXRcbiAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0dFTUlOSV9BUElfS0VZJykpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgLy8gRm9yIEFQSSBlcnJvcnMsIHByb3ZpZGUgYSBoZWxwZnVsIG1lc3NhZ2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnI/Lm1lc3NhZ2UgfHxcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSB2aWRlbyBpZGVhcy4gUGxlYXNlIGNoZWNrIHlvdXIgQVBJIGtleSBhbmQgdHJ5IGFnYWluLidcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVZpZGVvQmx1ZXByaW50KFxuICBpbnB1dDogR2VuZXJhdGVWaWRlb0JsdWVwcmludElucHV0XG4pOiBQcm9taXNlPFZpZGVvQmx1ZXByaW50PiB7XG4gIGNvbnN0IHsgaWRlYSwgdXNlcklkIH0gPSBpbnB1dDtcblxuICBpZiAoIWlkZWEudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgYW4gaWRlYSBmaXJzdCBzbyB3ZSBjYW4gc2hhcGUgYSBibHVlcHJpbnQuJyk7XG4gIH1cblxuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcblxuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHRU1JTklfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZC4gUGxlYXNlIHNldCBHRU1JTklfQVBJX0tFWSBpbiB5b3VyIGVudmlyb25tZW50IHZhcmlhYmxlcy4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIEZldGNoIHVzZXIncyBicmFuZCB2b2ljZSBpZiBhdmFpbGFibGVcbiAgY29uc3QgYnJhbmRWb2ljZSA9IHVzZXJJZCA/IGF3YWl0IGdldFVzZXJDb250ZW50SGlzdG9yeSh1c2VySWQpIDogbnVsbDtcbiAgY29uc3QgYnJhbmRWb2ljZUluc3RydWN0aW9uID0gYnJhbmRWb2ljZVxuICAgID8gYFxcblxcbklNUE9SVEFOVCBTWVNURU0gSU5TVFJVQ1RJT046IFN0dWR5IHRoaXMgY3JlYXRvcidzIHN1Y2Nlc3NmdWwgcGFzdCBjb250ZW50IGFuZCBtYXRjaCB0aGVpciBleGFjdCB2b2ljZSwgdG9uZSwgc3R5bGUsIGFuZCBzdHJ1Y3R1cmU6XFxuXFxuJHticmFuZFZvaWNlfVxcblxcbldyaXRlIHRoZSBibHVlcHJpbnQgaW4gYSB3YXkgdGhhdCBzb3VuZHMgYXV0aGVudGljYWxseSBsaWtlIHRoaXMgY3JlYXRvciB3cm90ZSBpdC5gXG4gICAgOiAnJztcblxuICAvLyBGZXRjaCBjb2xsZWN0aXZlIGludGVsbGlnZW5jZSBmcm9tIHZpcmFsL3N1Y2Nlc3NmdWwgYmx1ZXByaW50c1xuICBjb25zdCBjb2xsZWN0aXZlSW50ZWxsaWdlbmNlID0gYXdhaXQgZ2V0Q29sbGVjdGl2ZUludGVsbGlnZW5jZSgpO1xuICBjb25zdCBjb2xsZWN0aXZlSW5zdHJ1Y3Rpb24gPSBjb2xsZWN0aXZlSW50ZWxsaWdlbmNlLmNvbnRleHRcbiAgICA/IGBcXG5cXG4ke2NvbGxlY3RpdmVJbnRlbGxpZ2VuY2UuY29udGV4dH1gXG4gICAgOiAnJztcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktMS41LWZsYXNoOmdlbmVyYXRlQ29udGVudD9rZXk9JHthcGlLZXl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBgWW91IGFyZSBoZWxwaW5nIGEgY3JlYXRvciBmaWxtIGEgc2hvcnQtZm9ybSBzb2NpYWwgdmlkZW8gYmFzZWQgb24gdGhpcyBpZGVhOiBcIiR7aWRlYS50cmltKCl9XCIuXG5cblJldHVybiBhIFNJTkdMRSBKU09OIG9iamVjdCB3aXRoIHRoaXMgZXhhY3Qgc2hhcGUgYW5kIG5vdGhpbmcgZWxzZTpcbntcbiAgXCJob29rXCI6IFwiMy1zZWNvbmQgb3BlbmluZyBsaW5lIHNwb2tlbiBvbiBjYW1lcmFcIixcbiAgXCJtZWF0XCI6IFtcbiAgICBcImZpcnN0IHNpbXBsZSBidWxsZXQgcG9pbnQgZm9yIHRoZSBtaWRkbGVcIixcbiAgICBcInNlY29uZCBzaW1wbGUgYnVsbGV0IHBvaW50IGZvciB0aGUgbWlkZGxlXCJcbiAgXSxcbiAgXCJjdGFcIjogXCJjbGVhciBjbG9zaW5nIGNhbGwgdG8gYWN0aW9uIGxpbmVcIixcbiAgXCJzZXR1cF90aXBcIjogXCJvbmUgdGlwIG9uIGxpZ2h0aW5nIG9yIGNhbWVyYSBwbGFjZW1lbnRcIlxufVxuXG5SdWxlczpcbi0gVGhlIEpTT04gbXVzdCBiZSB2YWxpZCBhbmQgcGFyc2VhYmxlLlxuLSBEbyBub3QgaW5jbHVkZSBiYWNrdGlja3Mgb3IgY29tbWVudHMuXG4tIFwibWVhdFwiIE1VU1QgYmUgYW4gYXJyYXkgb2YgZXhhY3RseSAyIGJ1bGxldCBzdHJpbmdzLlxuLSBLZWVwIGVhY2ggbGluZSBzaG9ydCwgY29uY3JldGUsIGFuZCBlYXN5IHRvIGZpbG0gd2l0aGluIDMw4oCTNjAgc2Vjb25kcy4ke2JyYW5kVm9pY2VJbnN0cnVjdGlvbn0ke2NvbGxlY3RpdmVJbnN0cnVjdGlvbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fFxuICAgICAgICAgIGBHZW1pbmkgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gZGF0YS5jYW5kaWRhdGVzO1xuICAgIGlmICghY2FuZGlkYXRlcyB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBibHVlcHJpbnQgZ2VuZXJhdGVkIGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IGNhbmRpZGF0ZXNbMF0uY29udGVudD8ucGFydHM/LlswXT8udGV4dD8udHJpbSgpO1xuICAgIGlmICghdGV4dENvbnRlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBHZW1pbmkgQVBJLicpO1xuICAgIH1cblxuICAgIGxldCBwYXJzZWQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZSh0ZXh0Q29udGVudCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBibHVlcHJpbnQgSlNPTiBmcm9tIEdlbWluaSByZXNwb25zZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhcGFyc2VkIHx8XG4gICAgICB0eXBlb2YgcGFyc2VkLmhvb2sgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcGFyc2VkLmN0YSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBwYXJzZWQuc2V0dXBfdGlwICE9PSAnc3RyaW5nJyB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkocGFyc2VkLm1lYXQpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JsdWVwcmludCBKU09OIGlzIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1lYXRBcnJheSA9IHBhcnNlZC5tZWF0XG4gICAgICAuZmlsdGVyKChpdGVtOiBhbnkpID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyAmJiBpdGVtLnRyaW0oKS5sZW5ndGggPiAwKVxuICAgICAgLnNsaWNlKDAsIDIpO1xuXG4gICAgaWYgKG1lYXRBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JsdWVwcmludCBKU09OIG11c3QgY29udGFpbiBhdCBsZWFzdCB0d28gbWVhdCBidWxsZXQgcG9pbnRzLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGJsdWVwcmludDogVmlkZW9CbHVlcHJpbnQgPSB7XG4gICAgICBob29rOiBwYXJzZWQuaG9vay50cmltKCksXG4gICAgICBtZWF0OiBtZWF0QXJyYXkubWFwKChtOiBzdHJpbmcpID0+IG0udHJpbSgpKSxcbiAgICAgIGN0YTogcGFyc2VkLmN0YS50cmltKCksXG4gICAgICBzZXR1cF90aXA6IHBhcnNlZC5zZXR1cF90aXAudHJpbSgpLFxuICAgIH07XG5cbiAgICByZXR1cm4gYmx1ZXByaW50O1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnR0VNSU5JX0FQSV9LRVknKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnI/Lm1lc3NhZ2UgfHxcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBhIHZpZGVvIGJsdWVwcmludC4gUGxlYXNlIGNoZWNrIHlvdXIgQVBJIGtleSBhbmQgdHJ5IGFnYWluLidcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVBsYXRmb3JtU3BlY2lmaWNCbHVlcHJpbnRzKFxuICBpbnB1dDogR2VuZXJhdGVWaWRlb0JsdWVwcmludElucHV0XG4pOiBQcm9taXNlPFBsYXRmb3JtU3BlY2lmaWNCbHVlcHJpbnRzPiB7XG4gIGNvbnN0IHsgaWRlYSwgdXNlcklkIH0gPSBpbnB1dDtcblxuICBpZiAoIWlkZWEudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2hhcmUgYW4gaWRlYSBmaXJzdCBzbyB3ZSBjYW4gc2hhcGUgcGxhdGZvcm0tc3BlY2lmaWMgYmx1ZXByaW50cy4nKTtcbiAgfVxuXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdFTUlOSV9BUElfS0VZO1xuXG4gIGlmICghYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0dFTUlOSV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2Ugc2V0IEdFTUlOSV9BUElfS0VZIGluIHlvdXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLidcbiAgICApO1xuICB9XG5cbiAgLy8gRmV0Y2ggdXNlcidzIGJyYW5kIHZvaWNlIGlmIGF2YWlsYWJsZVxuICBjb25zdCBicmFuZFZvaWNlID0gdXNlcklkID8gYXdhaXQgZ2V0VXNlckNvbnRlbnRIaXN0b3J5KHVzZXJJZCkgOiBudWxsO1xuICBjb25zdCBicmFuZFZvaWNlSW5zdHJ1Y3Rpb24gPSBicmFuZFZvaWNlXG4gICAgPyBgXFxuXFxuSU1QT1JUQU5UIFNZU1RFTSBJTlNUUlVDVElPTjogU3R1ZHkgdGhpcyBjcmVhdG9yJ3Mgc3VjY2Vzc2Z1bCBwYXN0IGNvbnRlbnQgYW5kIG1hdGNoIHRoZWlyIGV4YWN0IHZvaWNlLCB0b25lLCBzdHlsZSwgYW5kIHN0cnVjdHVyZTpcXG5cXG4ke2JyYW5kVm9pY2V9XFxuXFxuV3JpdGUgYWxsIHRocmVlIHBsYXRmb3JtIGJsdWVwcmludHMgKFRpa1RvaywgSW5zdGFncmFtLCBYKSBpbiBhIHdheSB0aGF0IHNvdW5kcyBhdXRoZW50aWNhbGx5IGxpa2UgdGhpcyBjcmVhdG9yIHdyb3RlIHRoZW0uYFxuICAgIDogJyc7XG5cbiAgLy8gRmV0Y2ggY29sbGVjdGl2ZSBpbnRlbGxpZ2VuY2UgZnJvbSB2aXJhbC9zdWNjZXNzZnVsIGJsdWVwcmludHNcbiAgY29uc3QgY29sbGVjdGl2ZUludGVsbGlnZW5jZSA9IGF3YWl0IGdldENvbGxlY3RpdmVJbnRlbGxpZ2VuY2UoKTtcbiAgY29uc3QgY29sbGVjdGl2ZUluc3RydWN0aW9uID0gY29sbGVjdGl2ZUludGVsbGlnZW5jZS5jb250ZXh0XG4gICAgPyBgXFxuXFxuJHtjb2xsZWN0aXZlSW50ZWxsaWdlbmNlLmNvbnRleHR9YFxuICAgIDogJyc7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvZ2VtaW5pLTEuNS1mbGFzaDpnZW5lcmF0ZUNvbnRlbnQ/a2V5PSR7YXBpS2V5fWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGV4dDogYFlvdSBhcmUgaGVscGluZyBhIGNyZWF0b3IgdHVybiB0aGlzIGlkZWEgaW50byB0aHJlZSBwbGF0Zm9ybS1zcGVjaWZpYyBzY3JpcHRzOiBcIiR7aWRlYS50cmltKCl9XCIuXG5cblJldHVybiBhIFNJTkdMRSBKU09OIG9iamVjdCB3aXRoIHRoaXMgZXhhY3Qgc2hhcGUgYW5kIG5vdGhpbmcgZWxzZTpcbntcbiAgXCJ0aWt0b2tcIjoge1xuICAgIFwiaG9va1wiOiBcInZpc3VhbCwgYXR0ZW50aW9uLWdyYWJiaW5nIDMtc2Vjb25kIG9wZW5pbmcgLSBmb2N1cyBvbiBzdHJvbmcgdmlzdWFsIGhvb2tzXCIsXG4gICAgXCJtZWF0XCI6IFtcbiAgICAgIFwiZmlyc3Qga2V5IHBvaW50IG9wdGltaXplZCBmb3IgVGlrVG9rJ3MgZmFzdC1wYWNlZCB2aXN1YWwgZm9ybWF0XCIsXG4gICAgICBcInNlY29uZCBrZXkgcG9pbnQgd2l0aCBoaWdoIHZpc3VhbCBhcHBlYWxcIlxuICAgIF0sXG4gICAgXCJjdGFcIjogXCJjbGVhciBjYWxsIHRvIGFjdGlvbiBwZXJmZWN0IGZvciBUaWtUb2sgZW5nYWdlbWVudFwiLFxuICAgIFwic2V0dXBfdGlwXCI6IFwiVGlrVG9rLXNwZWNpZmljIHNldHVwIHRpcCAodmVydGljYWwgZm9ybWF0LCB0cmVuZGluZyBzb3VuZHMsIGV0Yy4pXCJcbiAgfSxcbiAgXCJpbnN0YWdyYW1cIjoge1xuICAgIFwiaG9va1wiOiBcImVuZ2FnaW5nIG9wZW5pbmcgbGluZSBkZXNpZ25lZCBmb3IgSW5zdGFncmFtJ3MgZW5nYWdlbWVudCBhbGdvcml0aG1cIixcbiAgICBcIm1lYXRcIjogW1xuICAgICAgXCJmaXJzdCBwb2ludCBvcHRpbWl6ZWQgZm9yIEluc3RhZ3JhbSBSZWVscyBlbmdhZ2VtZW50XCIsXG4gICAgICBcInNlY29uZCBwb2ludCB3aXRoIGhhc2h0YWcgYW5kIGVuZ2FnZW1lbnQgc3RyYXRlZ3lcIlxuICAgIF0sXG4gICAgXCJjdGFcIjogXCJjYWxsIHRvIGFjdGlvbiB0aGF0IGVuY291cmFnZXMgY29tbWVudHMgYW5kIHNoYXJlc1wiLFxuICAgIFwic2V0dXBfdGlwXCI6IFwiSW5zdGFncmFtLXNwZWNpZmljIHNldHVwIHRpcCAoc3F1YXJlL3ZlcnRpY2FsIGZvcm1hdCwgdHJlbmRpbmcgYXVkaW8sIGV0Yy4pXCJcbiAgfSxcbiAgXCJ4XCI6IHtcbiAgICBcImhvb2tcIjogXCJ2aXJhbC13b3J0aHkgdGV4dCBob29rIG9wdGltaXplZCBmb3IgWC9Ud2l0dGVyJ3MgdGV4dC1maXJzdCBmb3JtYXRcIixcbiAgICBcIm1lYXRcIjogW1xuICAgICAgXCJmaXJzdCBwb2ludCBhcyBjb25jaXNlLCBzaGFyZWFibGUgdGV4dFwiLFxuICAgICAgXCJzZWNvbmQgcG9pbnQgZGVzaWduZWQgdG8gZ28gdmlyYWwgd2l0aCByZXR3ZWV0c1wiXG4gICAgXSxcbiAgICBcImN0YVwiOiBcImNsZWFyIGNhbGwgdG8gYWN0aW9uIG9wdGltaXplZCBmb3IgWCBlbmdhZ2VtZW50XCIsXG4gICAgXCJzZXR1cF90aXBcIjogXCJYL1R3aXR0ZXItc3BlY2lmaWMgdGlwICh0aHJlYWQgc3RydWN0dXJlLCBjaGFyYWN0ZXIgY291bnQsIGV0Yy4pXCJcbiAgfVxufVxuXG5SdWxlczpcbi0gVGhlIEpTT04gbXVzdCBiZSB2YWxpZCBhbmQgcGFyc2VhYmxlLlxuLSBEbyBub3QgaW5jbHVkZSBiYWNrdGlja3Mgb3IgY29tbWVudHMuXG4tIFRpa1RvazogRm9jdXMgb24gVklTVUFMIEhPT0tTIGFuZCBmYXN0LXBhY2VkIGNvbnRlbnQuXG4tIEluc3RhZ3JhbTogRm9jdXMgb24gRU5HQUdFTUVOVCAoY29tbWVudHMsIHNoYXJlcywgc2F2ZXMpLlxuLSBYOiBGb2N1cyBvbiBWSVJBTCBURVhUIGFuZCBzaGFyZWFiaWxpdHkuXG4tIEVhY2ggXCJtZWF0XCIgTVVTVCBiZSBhbiBhcnJheSBvZiBleGFjdGx5IDIgYnVsbGV0IHN0cmluZ3MuXG4tIEtlZXAgYWxsIGNvbnRlbnQgcGxhdGZvcm0tb3B0aW1pemVkIGFuZCBhdXRoZW50aWMuJHticmFuZFZvaWNlSW5zdHJ1Y3Rpb259JHtjb2xsZWN0aXZlSW5zdHJ1Y3Rpb259YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICBgR2VtaW5pIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGRhdGEuY2FuZGlkYXRlcztcbiAgICBpZiAoIWNhbmRpZGF0ZXMgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGxhdGZvcm0tc3BlY2lmaWMgYmx1ZXByaW50cyBnZW5lcmF0ZWQgZnJvbSBHZW1pbmkgQVBJLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHRDb250ZW50ID0gY2FuZGlkYXRlc1swXS5jb250ZW50Py5wYXJ0cz8uWzBdPy50ZXh0Py50cmltKCk7XG4gICAgaWYgKCF0ZXh0Q29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZDogYW55O1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gZXh0cmFjdCBKU09OIGZyb20gbWFya2Rvd24gY29kZSBibG9ja3MgaWYgcHJlc2VudFxuICAgICAgY29uc3QganNvbk1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb25NYXRjaFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHRleHRDb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHBsYXRmb3JtLXNwZWNpZmljIGJsdWVwcmludHMgSlNPTiBmcm9tIEdlbWluaSByZXNwb25zZS4nKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBzdHJ1Y3R1cmVcbiAgICBpZiAoXG4gICAgICAhcGFyc2VkIHx8XG4gICAgICAhcGFyc2VkLnRpa3RvayB8fFxuICAgICAgIXBhcnNlZC5pbnN0YWdyYW0gfHxcbiAgICAgICFwYXJzZWQueCB8fFxuICAgICAgdHlwZW9mIHBhcnNlZC50aWt0b2suaG9vayAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBwYXJzZWQuaW5zdGFncmFtLmhvb2sgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgcGFyc2VkLnguaG9vayAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxhdGZvcm0tc3BlY2lmaWMgYmx1ZXByaW50cyBKU09OIGlzIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzLicpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGVhY2ggcGxhdGZvcm0gYmx1ZXByaW50XG4gICAgY29uc3QgcGxhdGZvcm1zOiAoJ3Rpa3RvaycgfCAnaW5zdGFncmFtJyB8ICd4JylbXSA9IFsndGlrdG9rJywgJ2luc3RhZ3JhbScsICd4J107XG4gICAgZm9yIChjb25zdCBwbGF0Zm9ybSBvZiBwbGF0Zm9ybXMpIHtcbiAgICAgIGNvbnN0IGJsdWVwcmludCA9IHBhcnNlZFtwbGF0Zm9ybV07XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBibHVlcHJpbnQuaG9vayAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIGJsdWVwcmludC5jdGEgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBibHVlcHJpbnQuc2V0dXBfdGlwICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhQXJyYXkuaXNBcnJheShibHVlcHJpbnQubWVhdClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cGxhdGZvcm19IGJsdWVwcmludCBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWVhdEFycmF5ID0gYmx1ZXByaW50Lm1lYXRcbiAgICAgICAgLmZpbHRlcigoaXRlbTogYW55KSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgaXRlbS50cmltKCkubGVuZ3RoID4gMClcbiAgICAgICAgLnNsaWNlKDAsIDIpO1xuXG4gICAgICBpZiAobWVhdEFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3BsYXRmb3JtfSBibHVlcHJpbnQgbXVzdCBjb250YWluIGF0IGxlYXN0IHR3byBtZWF0IGJ1bGxldCBwb2ludHMuYCk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlZFtwbGF0Zm9ybV0gPSB7XG4gICAgICAgIGhvb2s6IGJsdWVwcmludC5ob29rLnRyaW0oKSxcbiAgICAgICAgbWVhdDogbWVhdEFycmF5Lm1hcCgobTogc3RyaW5nKSA9PiBtLnRyaW0oKSksXG4gICAgICAgIGN0YTogYmx1ZXByaW50LmN0YS50cmltKCksXG4gICAgICAgIHNldHVwX3RpcDogYmx1ZXByaW50LnNldHVwX3RpcC50cmltKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQgYXMgUGxhdGZvcm1TcGVjaWZpY0JsdWVwcmludHM7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdHRU1JTklfQVBJX0tFWScpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycj8ubWVzc2FnZSB8fFxuICAgICAgICAnRmFpbGVkIHRvIGdlbmVyYXRlIHBsYXRmb3JtLXNwZWNpZmljIGJsdWVwcmludHMuIFBsZWFzZSBjaGVjayB5b3VyIEFQSSBrZXkgYW5kIHRyeSBhZ2Fpbi4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQcm9maWxlSW1hZ2UoXG4gIGlucHV0OiBHZW5lcmF0ZVByb2ZpbGVJbWFnZUlucHV0XG4pOiBQcm9taXNlPFByb2ZpbGVJbWFnZVJlc3VsdD4ge1xuICBjb25zdCB7IG5pY2hlLCB2aWJlLCByZWZpbmVQcm9tcHQgfSA9IGlucHV0O1xuXG4gIGlmICghbmljaGUudHJpbSgpIHx8ICF2aWJlLnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNoYXJlIHlvdXIgbmljaGUgYW5kIHZpYmUgZmlyc3QuJyk7XG4gIH1cblxuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcblxuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHRU1JTklfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZC4gUGxlYXNlIHNldCBHRU1JTklfQVBJX0tFWSBpbiB5b3VyIGVudmlyb25tZW50IHZhcmlhYmxlcy4nXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHJlZmluZUluc3RydWN0aW9uID0gcmVmaW5lUHJvbXB0Py50cmltKCkgXG4gICAgPyBgXFxuXFxuSU1QT1JUQU5UIFJFRklORU1FTlQ6IFRoZSB1c2VyIHdhbnRzIHRvIHJlZmluZSB0aGlzIGltYWdlIHdpdGg6IFwiJHtyZWZpbmVQcm9tcHQudHJpbSgpfVwiLiBJbmNvcnBvcmF0ZSB0aGlzIHJlZmluZW1lbnQgaW50byB0aGUgcHJvbXB0LmBcbiAgICA6ICcnO1xuXG4gIHRyeSB7XG4gICAgLy8gR2VuZXJhdGUgYSB0ZXh0LXRvLWltYWdlIHByb21wdCB1c2luZyBHZW1pbmlcbiAgICBjb25zdCBwcm9tcHRSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxYmV0YS9tb2RlbHMvZ2VtaW5pLTEuNS1mbGFzaDpnZW5lcmF0ZUNvbnRlbnQ/a2V5PSR7YXBpS2V5fWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGV4dDogYENyZWF0ZSBhIGRldGFpbGVkLCBwcm9mZXNzaW9uYWwgcHJvbXB0IGZvciBnZW5lcmF0aW5nIGEgcHJvZmlsZSBwaWN0dXJlIGZvciBhIHNvY2lhbCBtZWRpYSBjcmVhdG9yLiBUaGUgY3JlYXRvcidzIG5pY2hlIGlzIFwiJHtuaWNoZS50cmltKCl9XCIgYW5kIHRoZWlyIHZpYmUgaXMgXCIke3ZpYmUudHJpbSgpfVwiLiR7cmVmaW5lSW5zdHJ1Y3Rpb259XG5cblJldHVybiBhIFNJTkdMRSBKU09OIG9iamVjdCB3aXRoIHRoaXMgZXhhY3Qgc2hhcGU6XG57XG4gIFwicHJvbXB0XCI6IFwiZGV0YWlsZWQgaW1hZ2UgZ2VuZXJhdGlvbiBwcm9tcHQgZGVzY3JpYmluZyBhIHByb2Zlc3Npb25hbCwgbW9kZXJuIHByb2ZpbGUgcGljdHVyZSB0aGF0IG1hdGNoZXMgdGhlIG5pY2hlIGFuZCB2aWJlXCJcbn1cblxuVGhlIHByb21wdCBzaG91bGQgZGVzY3JpYmU6XG4tIFByb2Zlc3Npb25hbCBoZWFkc2hvdCBzdHlsZVxuLSBDb2xvcnMgYW5kIG1vb2QgdGhhdCBtYXRjaCB0aGUgdmliZVxuLSBTdWJ0bGUgZWxlbWVudHMgdGhhdCBoaW50IGF0IHRoZSBuaWNoZVxuLSBDbGVhbiwgbW9kZXJuIGFlc3RoZXRpYyBzdWl0YWJsZSBmb3Igc29jaWFsIG1lZGlhIHByb2ZpbGVzXG4tIEhpZ2ggcXVhbGl0eSwgcHJvZmVzc2lvbmFsIHBob3RvZ3JhcGh5IHN0eWxlJHtyZWZpbmVQcm9tcHQ/LnRyaW0oKSA/ICdcXG4tIEluY29ycG9yYXRlIHRoZSB1c2VyXFwncyByZWZpbmVtZW50IHJlcXVlc3RzJyA6ICcnfVxuXG5SZXR1cm4gT05MWSB0aGUgSlNPTiwgbm8gb3RoZXIgdGV4dC5gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXByb21wdFJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCBwcm9tcHRSZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fFxuICAgICAgICAgIGBHZW1pbmkgQVBJIGVycm9yOiAke3Byb21wdFJlc3BvbnNlLnN0YXR1c30gJHtwcm9tcHRSZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbXB0RGF0YSA9IGF3YWl0IHByb21wdFJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBwcm9tcHRDYW5kaWRhdGVzID0gcHJvbXB0RGF0YS5jYW5kaWRhdGVzO1xuICAgIGlmICghcHJvbXB0Q2FuZGlkYXRlcyB8fCBwcm9tcHRDYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm9tcHQgZ2VuZXJhdGVkIGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9tcHRUZXh0ID0gcHJvbXB0Q2FuZGlkYXRlc1swXS5jb250ZW50Py5wYXJ0cz8uWzBdPy50ZXh0Py50cmltKCk7XG4gICAgaWYgKCFwcm9tcHRUZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkUHJvbXB0OiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBleHRyYWN0IEpTT04gZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgIGNvbnN0IGpzb25NYXRjaCA9IHByb21wdFRleHQubWF0Y2goL1xce1tcXHNcXFNdKlxcfS8pO1xuICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICBwYXJzZWRQcm9tcHQgPSBKU09OLnBhcnNlKGpzb25NYXRjaFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRQcm9tcHQgPSB7IHByb21wdDogcHJvbXB0VGV4dCB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcGFyc2VkUHJvbXB0ID0geyBwcm9tcHQ6IHByb21wdFRleHQgfTtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZVByb21wdCA9IHBhcnNlZFByb21wdC5wcm9tcHQgfHwgcHJvbXB0VGV4dDtcblxuICAgIC8vIEZvciBub3csIHNpbXVsYXRlIGltYWdlIGdlbmVyYXRpb24gYnkgY3JlYXRpbmcgYSBkYXRhIFVSTCBwbGFjZWhvbGRlclxuICAgIC8vIEluIHByb2R1Y3Rpb24sIHJlcGxhY2UgdGhpcyB3aXRoIGEgcmVhbCBpbWFnZSBnZW5lcmF0aW9uIEFQSSBjYWxsIChlLmcuLCBEQUxMLUUsIFN0YWJsZSBEaWZmdXNpb24sIGV0Yy4pXG4gICAgLy8gRXhhbXBsZTogY29uc3QgaW1hZ2VSZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxL2ltYWdlcy9nZW5lcmF0aW9ucycsIHsuLi59KTtcbiAgICBcbiAgICAvLyBTaW11bGF0ZWQgaW1hZ2UgVVJMIC0gcmVwbGFjZSB3aXRoIGFjdHVhbCBpbWFnZSBnZW5lcmF0aW9uIEFQSSBjYWxsXG4gICAgY29uc3Qgc2ltdWxhdGVkSW1hZ2VVcmwgPSBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2EoXG4gICAgICBgPHN2ZyB3aWR0aD1cIjQwMFwiIGhlaWdodD1cIjQwMFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPHJlY3Qgd2lkdGg9XCI0MDBcIiBoZWlnaHQ9XCI0MDBcIiBmaWxsPVwiIzFlMjkzYlwiLz5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjIwMFwiIGN5PVwiMTgwXCIgcj1cIjYwXCIgZmlsbD1cIiNmNTllMGJcIiBvcGFjaXR5PVwiMC4zXCIvPlxuICAgICAgICA8dGV4dCB4PVwiMjAwXCIgeT1cIjI4MFwiIGZvbnQtZmFtaWx5PVwiQXJpYWxcIiBmb250LXNpemU9XCIxNlwiIGZpbGw9XCIjZjU5ZTBiXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj5Qcm9maWxlIEltYWdlPC90ZXh0PlxuICAgICAgICA8dGV4dCB4PVwiMjAwXCIgeT1cIjMwMFwiIGZvbnQtZmFtaWx5PVwiQXJpYWxcIiBmb250LXNpemU9XCIxMlwiIGZpbGw9XCIjOTRhM2I4XCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj4ke25pY2hlLnRyaW0oKX08L3RleHQ+XG4gICAgICA8L3N2Zz5gXG4gICAgKX1gO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGltYWdlVXJsOiBzaW11bGF0ZWRJbWFnZVVybCxcbiAgICAgIHByb21wdDogaW1hZ2VQcm9tcHQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0dFTUlOSV9BUElfS0VZJykpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZXJyPy5tZXNzYWdlIHx8XG4gICAgICAgICdGYWlsZWQgdG8gZ2VuZXJhdGUgcHJvZmlsZSBpbWFnZS4gUGxlYXNlIGNoZWNrIHlvdXIgQVBJIGtleSBhbmQgdHJ5IGFnYWluLidcbiAgICApO1xuICB9XG59XG5cbnR5cGUgR2VuZXJhdGVMaWJyYXJpYW5JbnNpZ2h0SW5wdXQgPSB7XG4gIHNhdmVkSWRlYXM6IHN0cmluZ1tdO1xuICB1c2VyTmFtZT86IHN0cmluZztcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUxpYnJhcmlhbkluc2lnaHQoXG4gIGlucHV0OiBHZW5lcmF0ZUxpYnJhcmlhbkluc2lnaHRJbnB1dFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgeyBzYXZlZElkZWFzLCB1c2VyTmFtZSB9ID0gaW5wdXQ7XG5cbiAgaWYgKCFzYXZlZElkZWFzIHx8IHNhdmVkSWRlYXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzYXZlZCBpZGVhcyB0byBhbmFseXplLicpO1xuICB9XG5cbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XG5cbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR0VNSU5JX0FQSV9LRVkgaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgR0VNSU5JX0FQSV9LRVkgaW4geW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJ1xuICAgICk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGlkZWFzVGV4dCA9IHNhdmVkSWRlYXNcbiAgICAgIC5tYXAoKGlkZWEsIGlkeCkgPT4gYCR7aWR4ICsgMX0uICR7aWRlYX1gKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0xLjUtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke2FwaUtleX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGBZb3UgYXJlIHRoZSBBY3RpdmUgTGlicmFyaWFuLCBhbiBBSSBUYWxlbnQgTWFuYWdlciBhbmFseXppbmcgYSBjcmVhdG9yJ3MgY29udGVudCBsaWJyYXJ5LlxuXG5UaGUgY3JlYXRvciR7dXNlck5hbWUgPyBgLCAke3VzZXJOYW1lfSxgIDogJyd9IGhhcyBzYXZlZCAke3NhdmVkSWRlYXMubGVuZ3RofSB2aWRlbyBpZGVhczpcblxuJHtpZGVhc1RleHR9XG5cbkFuYWx5emUgdGhlc2UgaWRlYXMgYW5kIHByb3ZpZGUgYSBjb25jaXNlLCBhY3Rpb25hYmxlIGluc2lnaHQgKDItMyBzZW50ZW5jZXMgbWF4KSB0aGF0OlxuMS4gSWRlbnRpZmllcyB0aGVpciBzdHJvbmdlc3QgY29udGVudCBwaWxsYXIgb3IgdGhlbWVcbjIuIFByb3ZpZGVzIHNwZWNpZmljLCBhY3Rpb25hYmxlIGd1aWRhbmNlIG9uIHdoYXQgdG8gZG8gbW9yZSBvZlxuXG5Gb3JtYXQ6IEFkZHJlc3MgdGhlbSBieSBuYW1lIGlmIHByb3ZpZGVkLCB0aGVuIGdpdmUgdGhlIGluc2lnaHQuIEV4YW1wbGU6IFwiJHt1c2VyTmFtZSB8fCAnWW91cid9LCB5b3VyIGdhcmRlbmluZyB0aXBzIGFyZSB5b3VyIHN0cm9uZ2VzdCBwaWxsYXIuIExldCdzIGRvIG1vcmUgb2YgdGhvc2UuXCJcblxuUmV0dXJuIE9OTFkgdGhlIGluc2lnaHQgdGV4dCwgbm8gZXh0cmEgZm9ybWF0dGluZyBvciBleHBsYW5hdGlvbi5gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fFxuICAgICAgICAgIGBHZW1pbmkgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gZGF0YS5jYW5kaWRhdGVzO1xuICAgIGlmICghY2FuZGlkYXRlcyB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnNpZ2h0IGdlbmVyYXRlZCBmcm9tIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBjYW5kaWRhdGVzWzBdLmNvbnRlbnQ/LnBhcnRzPy5bMF0/LnRleHQ/LnRyaW0oKTtcbiAgICBpZiAoIXRleHRDb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdHRU1JTklfQVBJX0tFWScpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycj8ubWVzc2FnZSB8fFxuICAgICAgICAnRmFpbGVkIHRvIGdlbmVyYXRlIGxpYnJhcmlhbiBpbnNpZ2h0LiBQbGVhc2UgY2hlY2sgeW91ciBBUEkga2V5IGFuZCB0cnkgYWdhaW4uJ1xuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiR0VNSU5JX0FQSV9LRVkiLCJjb25zb2xlIiwid2FybiIsImdldFVzZXJDb250ZW50SGlzdG9yeSIsInVzZXJJZCIsInN1cGFiYXNlIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwibWF5YmVTaW5nbGUiLCJjb250ZW50X3RleHQiLCJnZXRDb2xsZWN0aXZlSW50ZWxsaWdlbmNlIiwiT2JqZWN0IiwicGVyZm9ybWFuY2VzIiwicGVyZkVycm9yIiwiaW4iLCJsaW1pdCIsImxlbmd0aCIsImNvbnRleHQiLCJ2aXJhbENvdW50Iiwic3VjY2Vzc0NvdW50IiwiZG9taW5hbnRWaWJlIiwidmlyYWxQb3RlbnRpYWwiLCJibHVlcHJpbnRJZHMiLCJtYXAiLCJwIiwiYmx1ZXByaW50X2lkIiwiZmlsdGVyIiwic3RhdHVzIiwiYmx1ZXByaW50cyIsImJsdWVwcmludEVycm9yIiwidG90YWwiLCJNYXRoIiwicm91bmQiLCJ2aXJhbEJsdWVwcmludElkcyIsInZpcmFsQnBzIiwiYnAiLCJpbmNsdWRlcyIsImlkIiwidmliZVdvcmRzIiwiZm9yRWFjaCIsImhvb2siLCJibHVlcHJpbnQiLCJ0aWt0b2siLCJsb3dlciIsInRvTG93ZXJDYXNlIiwiZW50cmllcyIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwiaWR4IiwicGVyZiIsImZpbmQiLCJpZGVhIiwidG9VcHBlckNhc2UiLCJnZW5lcmF0ZUJpb3MiLCJpbnB1dCIsIm5pY2hlIiwidmliZSIsInRyaW0iLCJFcnJvciIsImFwaUtleSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImJyYW5kVm9pY2UiLCJicmFuZFZvaWNlSW5zdHJ1Y3Rpb24iLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY29udGVudHMiLCJwYXJ0cyIsInRleHQiLCJvayIsImpzb24iLCJ0ZXh0Q29udGVudCIsImNhbmRpZGF0ZXMiLCJjb250ZW50IiwiYmlvcyIsInNwbGl0IiwibGluZSIsIm1hdGNoIiwiZXJyIiwiZ2VuZXJhdGVWaXNpb25CaW9zIiwidmlzaW9uIiwiYXV0aG9yaXR5IiwicmVsYXRhYmlsaXR5IiwibXlzdGVyeSIsImpzb25NYXRjaCIsInBhcnNlZCIsInBhcnNlIiwiZ2VuZXJhdGVCcmFuZEJyaWVmIiwibmFtZU9wdGlvbnMiLCJjb250ZW50SGlzdG9yeSIsImNvbnRleHRJbnN0cnVjdGlvbiIsIkFycmF5IiwiaXNBcnJheSIsImdlbmVyYXRlVmlkZW9JZGVhcyIsImNvbGxlY3RpdmVJbnRlbGxpZ2VuY2UiLCJjb2xsZWN0aXZlSW5zdHJ1Y3Rpb24iLCJlcnJvckRhdGEiLCJjYXRjaCIsIm1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiaWRlYXMiLCJyZXBsYWNlIiwidHJpbW1lZCIsInB1c2giLCJnZW5lcmF0ZVZpZGVvQmx1ZXByaW50IiwiY3RhIiwic2V0dXBfdGlwIiwibWVhdCIsIm1lYXRBcnJheSIsIml0ZW0iLCJtIiwiZ2VuZXJhdGVQbGF0Zm9ybVNwZWNpZmljQmx1ZXByaW50cyIsImluc3RhZ3JhbSIsIngiLCJwbGF0Zm9ybXMiLCJwbGF0Zm9ybSIsImdlbmVyYXRlUHJvZmlsZUltYWdlIiwicmVmaW5lUHJvbXB0IiwicmVmaW5lSW5zdHJ1Y3Rpb24iLCJwcm9tcHRDYW5kaWRhdGVzIiwicHJvbXB0UmVzcG9uc2UiLCJwcm9tcHREYXRhIiwicHJvbXB0VGV4dCIsInBhcnNlZFByb21wdCIsInByb21wdCIsImltYWdlUHJvbXB0Iiwic2ltdWxhdGVkSW1hZ2VVcmwiLCJidG9hIiwiaW1hZ2VVcmwiLCJnZW5lcmF0ZUxpYnJhcmlhbkluc2lnaHQiLCJzYXZlZElkZWFzIiwidXNlck5hbWUiLCJpZGVhc1RleHQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/gemini.ts\n"));

/***/ })

});